<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    		<meta name="keywords" content="Talk:Boolean satisfiability problem/Archive 1,Boolean circuit,Cook's theorem,NP (complexity),Pigeonhole principle,WP:NOR,Boolean satisfiability problem,Boolean satisfiability problem/Archive02,Aristk,Dcoetzee,Gdr" />
		<link rel="shortcut icon" href="/favicon.ico" />
		<link rel="search" type="application/opensearchdescription+xml" href="/w/opensearch_desc.php" title="Wikipedia (English)" />
		<link rel="copyright" href="../../../COPYING.html" />
    <title>Talk:Boolean satisfiability problem/Archive 1 - Wikipedia, the free encyclopedia</title>
    <style type="text/css">/*<![CDATA[*/ @import "../../../skins/htmldump/main.css"; /*]]>*/</style>
    <link rel="stylesheet" type="text/css" media="print" href="../../../skins/common/commonPrint.css" />
    <!--[if lt IE 5.5000]><style type="text/css">@import "../../../skins/monobook/IE50Fixes.css";</style><![endif]-->
    <!--[if IE 5.5000]><style type="text/css">@import "../../../skins/monobook/IE55Fixes.css";</style><![endif]-->
    <!--[if IE 6]><style type="text/css">@import "../../../skins/monobook/IE60Fixes.css";</style><![endif]-->
    <!--[if IE]><script type="text/javascript" src="../../../skins/common/IEFixes.js"></script>
    <meta http-equiv="imagetoolbar" content="no" /><![endif]-->
    <script type="text/javascript" src="../../../skins/common/wikibits.js"></script>
    <script type="text/javascript" src="../../../skins/htmldump/md5.js"></script>
    <script type="text/javascript" src="../../../skins/htmldump/utf8.js"></script>
    <script type="text/javascript" src="../../../skins/htmldump/lookup.js"></script>
    <script type="text/javascript" src="../../../raw/gen.js"></script>        <style type="text/css">/*<![CDATA[*/
@import "../../../raw/MediaWiki%7ECommon.css";
@import "../../../raw/MediaWiki%7EMonobook.css";
@import "../../../raw/gen.css";
/*]]>*/</style>          </head>
  <body
    class="ns-1">
    <div id="globalWrapper">
      <div id="column-content">
	<div id="content">
	  <a name="top" id="contentTop"></a>
	        <h1 class="firstHeading">Talk:Boolean satisfiability problem/Archive 1</h1>
	  <div id="bodyContent">
	    <h3 id="siteSub">From Wikipedia, the free encyclopedia</h3>
	    <div id="contentSub"><span class="subpages">&lt; <a href="../../../b/o/o/Talk%7EBoolean_satisfiability_problem_53de.html" title="Talk:Boolean satisfiability problem">Talk:Boolean satisfiability problem</a></span></div>
	    	    <div class="usermessage">You have <a href="../../../1/2/7/User_talk%7E127.0.0.1.html" title="User talk:127.0.0.1">new messages</a> (<a href="../../../1/2/7/User_talk%7E127.0.0.1.html" title="User talk:127.0.0.1">last change</a>).</div>	    <!-- start content -->
	    <table class="messagebox standard-talk">
<tr>
<td><a href="../../../v/i/s/Image%7EVista-file-manager.png_cc3f.html" class="image" title="Archive"><img src="../../../upload/thumb/c/c2/Vista-file-manager.png/50px-Vista-file-manager.png" alt="Archive" width="50" height="50" longdesc="../../../v/i/s/Image%7EVista-file-manager.png_cc3f.html" /></a></td>
<td>This is an <b><a href="../../../h/o/w/Wikipedia%7EHow_to_archive_a_talk_page_629d.html" title="Wikipedia:How to archive a talk page">archive</a></b> of past discussions. <b>Do not edit the contents of this page.</b> If you wish to start a new discussion or revive an old one, please do so on the <span class="plainlinks"><a href="http://en.wikipedia.org../../../b/o/o/Talk%7EBoolean_satisfiability_problem_53de.html" class="external text" title="http://en.wikipedia.org../../../b/o/o/Talk%7EBoolean_satisfiability_problem_53de.html" rel="nofollow">current talk page</a></span>.</td>
</tr>
</table>
<p><b>DO NOT EDIT OR POST REPLIES TO THIS PAGE. THIS PAGE IS AN ARCHIVE.</b></p>
<p>This archive page covers approximately the dates between the page creation and 18/10/2005.</p>
<p>Post replies to the <a href="../../../b/o/o/Talk%7EBoolean_satisfiability_problem_53de.html" title="Talk:Boolean satisfiability problem">main talk page</a>, copying or summarizing the section you are replying to if necessary.</p>
<p>Please add new archivals to Talk:Boolean satisfiability problem/Archive02. (See <a href="../../../h/o/w/Wikipedia%7EHow_to_archive_a_talk_page_629d.html" title="Wikipedia:How to archive a talk page">Wikipedia:How to archive a talk page</a>.) Thank you. Paolo Liberatore&#160;(<a href="../../../p/a/o/User_talk%7EPaolo_Liberatore_53e0.html" title="User talk:Paolo Liberatore">Talk</a>) 13:41, 19 October 2005 (UTC)</p>
<hr />
<p>I understood that DNF boolean satisfiability is in P. This article seems to say it's NP-Complete. Since I'm not 100% sure of this, I'm not going to edit the article, but maybe someone else knows the definitive answer?</p>
<dl>
<dd>Strange, you are right. It is easy to see that it is in P; a formula in DNF is satisfiable iff there is a clause without a contradiction. And that can be checked in linear time. What is also strange is the claim that the proof of NP-completeness is rather simple. As an instructor I have taught that proof myself, and even I don't think it's easy.&#160;:-) I'm a bit time-pressed at the moment, but I will put this on my to-do list. -- <a href="../../../j/a/n/User%7EJan_Hidders_5932.html" title="User:Jan Hidders">Jan Hidders</a> 17:26 Dec 6, 2002 (UTC)</dd>
</dl>
<table id="toc" class="toc" summary="Contents">
<tr>
<td>
<div id="toctitle">
<h2>Contents</h2>
</div>
<ul>
<li class="toclevel-1"><a href="#3-sat_vs_2-sat"><span class="tocnumber">1</span> <span class="toctext">3-sat vs 2-sat</span></a></li>
<li class="toclevel-1"><a href="#Proof_of_NP-completeness"><span class="tocnumber">2</span> <span class="toctext">Proof of NP-completeness</span></a>
<ul>
<li class="toclevel-2"><a href="#Proof_of_NP-completeness_2"><span class="tocnumber">2.1</span> <span class="toctext">Proof of NP-completeness</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Classes_of_algorithms_for_SAT"><span class="tocnumber">3</span> <span class="toctext">Classes of algorithms for SAT</span></a></li>
<li class="toclevel-1"><a href="#.E2.80.9CP_.3D_NP.E2.80.9D_Proved.21_.28Solution_Algorithm_for_3-SAT.29"><span class="tocnumber">4</span> <span class="toctext">“P = NP” Proved! (Solution Algorithm for 3-SAT)</span></a></li>
</ul>
</td>
</tr>
</table>
<p><script type="text/javascript">
//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>
</script><a name="3-sat_vs_2-sat"></a></p>
<h2><span class="mw-headline">3-sat vs 2-sat</span></h2>
<p>3-sat is NPC and 2-sat is not, why is it so?</p>
<p>It becomes a little strange because it means that it is not possible in polynomial time to convert from 3-sat to 2-sat in general.</p>
<p>This seems to be a little mystery to me.</p>
<dl>
<dd>There are formulas you can express in 3SAT that are not expressible in 2SAT. So it is not even possible in exponential time or, for that matter, in any time. Take for example the formula f = (X1 or X2 or X3). How would you express that with a conjunction of clauses with just 2 variables? The proof that this is not possible is fairly simple. -- <a href="../../../j/a/n/User%7EJan_Hidders_5932.html" title="User:Jan Hidders">Jan Hidders</a> 20:36, 9 Jun 2004 (UTC)</dd>
<dd>The intuition is that 2CNF formulas merely express a conjunction of implications (because A or B is the same as (not A) implies B.) The constraints you can express with 3CNF formulas are potentially much more complex. An example of this is that it's impossible to express the negation of the <a href="../../../p/i/g/Pigeonhole_principle.html" title="Pigeonhole principle">pigeonhole principle</a> for <i>k</i> holes using 2CNF, because it requires exponential resolution steps to show that it's unsatisfiable, and I believe that any 2CNF formula can be show unsatisfiable in a polynomial resolution steps (since only more terms with two literals can be generated, and there's only 4n<sup>2</sup> possible such terms). The surprising thing, though, is that the pigeonhole principle formulas have O(n<sup>2</sup>) terms, and all but O(n) of them do in fact have two literals. <a href="../../../d/c/o/User%7EDcoetzee_a2a7.html" title="User:Dcoetzee">Deco</a> 7 July 2005 06:29 (UTC)</dd>
</dl>
<p><a name="Proof_of_NP-completeness" id="Proof_of_NP-completeness"></a></p>
<h2><span class="mw-headline">Proof of NP-completeness</span></h2>
<p>I cut a section giving a "proof" that SAT is NP-complete, which I give below. I cut this section because it isn't really a proof, hardly even an outline, and because it uses concepts not developed in this article, such as <a href="../../../b/o/o/Boolean_circuit.html" title="Boolean circuit">Boolean circuit</a>. It looks to me as though the author of this material was following the presentation in Christos Papadimitriou's book <i>Complexity Theory</i>, which presents a way to encode problems in NP as Boolean circuits first and then proves Cook's theorem as a corollary. I think that in Wikipedia it is better to give a direct proof, so I gave one in the <a href="../../../c/o/o/Cook%27s_theorem.html" title="Cook's theorem">Cook's theorem</a> article. <a href="../../../g/d/r/User%7EGdr_e4cb.html" title="User:Gdr">Gdr</a> 20:53, 2004 Jul 21 (UTC)</p>
<p><a name="Proof_of_NP-completeness_2" id="Proof_of_NP-completeness_2"></a></p>
<h3><span class="mw-headline">Proof of NP-completeness</span></h3>
<p>We give here a sketch of the proof of NP-completeness. To prove that SAT is NP-complete we must show that</p>
<ol>
<li>SAT is in <b><a href="../../../n/p/_/NP_%28complexity%29_b5f8.html" title="NP (complexity)">NP</a></b>, and</li>
<li>all other <b>NP</b> problems can be reduced to it in polynomial time.</li>
</ol>
<p>First, notice that it is easy to verify a YES answer: simply plug in a given set of variable values and see if they make the expression true. Therefore the problem is in <b>NP</b>.</p>
<p>Next, consider an arbitrary problem <i>X</i> that is in <b>NP</b>. By definition, there must be an algorithm for checking certificates for YES answers to <i>X</i> in polynomial time. Given such an algorithm it is possible to construct a polynomial-time algorithm that, given the size of the certificate, constructs a <a href="../../../b/o/o/Boolean_circuit.html" title="Boolean circuit">boolean circuit</a> that is polynomially large in the certificate size and decides whether its input is a binary encoding of a valid certificate or not. This circuit can then be transformed by another polynomial-time algorithm into an equivalent boolean formula that is still polynomially large in the certificate size. It then holds that this formula is satisfiable iff there is a valid certificate, which means that we have reduced the original problem to SAT.</p>
<ul>
<li>I believe you are engaging in a circular proof. You're indirectly using Cook's theorem, aren't you? You can't use a theorem's result to prove the same result... <a href="../../../r/b/a/User%7ERbarreira_44f4.html" title="User:Rbarreira">Rbarreira</a> 7 July 2005 02:51 (UTC)</li>
<li>Agreed. We really have to give a reduction from an arbitrary NP problem somewhere, although it would've been fine to follow Papadimitriou's route and add a proof to the article on boolean circuits (whichever is simpler). <a href="../../../d/c/o/User%7EDcoetzee_a2a7.html" title="User:Dcoetzee">Deco</a> 7 July 2005 06:20 (UTC)</li>
</ul>
<p><a name="Classes_of_algorithms_for_SAT" id="Classes_of_algorithms_for_SAT"></a></p>
<h2><span class="mw-headline">Classes of algorithms for SAT</span></h2>
<p><i>There are two classes of high-performance algorithms for solving instances of SAT in practice:</i></p>
<dl>
<dd>Well actually, there is also Stalmarck's procedure, which is very different from DPLL and from the stochastic methods. It should be mentioned, too. --<a href="../../../z/e/n/User%7EZenogantner_31a3.html" title="User:Zenogantner">zeno</a> 10:54, 8 Apr 2005 (UTC)</dd>
</dl>
<p><br /></p>
<p><a name=".E2.80.9CP_.3D_NP.E2.80.9D_Proved.21_.28Solution_Algorithm_for_3-SAT.29"></a></p>
<h2><span class="mw-headline">“P = NP” Proved! (Solution Algorithm for 3-SAT)</span></h2>
<div style="border: solid; padding: 5pt;">
<p>The following proof of P=NP, submitted by an anonomous editor, should be presumed wrong because it has not been published in a peer-reviewed scientific journal. Other editors have commented that the proof appears wrong, but it is not their duty to prove it, as encyclopedias are not places for original research: see <a href="../../../n/o/r/WP%7ENOR_e27a.html" title="WP:NOR">WP:NOR</a>. Do not post other proofs about P=NP here unless they have already been published in peer-reviewed scientific journals.</p>
</div>
<p>The equivalence of the P and the NP computational complexity classes is proved by presenting a very simple procedure for the practical solution of the NP-complete Boolean satisfiability 3-SAT decision problem. Using some kind of a Gödel prime natural numbers coding plan, polynomial-time algorithms are established for finding the respective assignment solutions to every group of input clauses with the same variables and for determining from them the valid assignment solutions to the 3-SAT problem.</p>
<p>Theorem 1: Let C be a clause and P be a variable. Then (C Ú P) Ù (C Ú ~P) = C.</p>
<p>For a given 3-SAT problem with n variables P1, P2, P3, . . ., Pn:</p>
<ul>
<li>The input clause(s) that include the same k (1 £ k £ 3) variable(s) could be grouped together — the maximum count of these groups is the number nCk of combinations of n distinct objects taken k-at-a-time. For each group, there are at most 2k possible length-k input clauses. All 2k possible length-k clauses cannot be specified as input clauses at the same time because this would lead to a self-contradiction.</li>
</ul>
<ul>
<li>There could only be at most n possible input clause(s) that use only 1 variable since no variable Pj (1 £ j £ n) can appear in one length-1 input clause as “Pj” and as “~Pj” in another length-1 input clause because this would bring about a self-contradiction — Pj Ù ~Pj — and, indubitably, one of them is not satisfiable by any truth-value assignment to Pj so there is no assignment solution to the 3-SAT decision problem. The length-1 input clause(s), if any, already fixes the truth-value(s) of their respective variable(s) in the assignment solution. Hence, they could actually be dispensed with in any 3-SAT decision problem and the number of variables reduced.</li>
</ul>
<ul>
<li>By Theorem 1, any length-2 input clause — Pi Ú Pj — could always be replaced by 2 length-3 clauses — Pi Ú Pj Ú Pk and Pi Ú Pj Ú ~Pk. These replacements (as well as the replacements of one length-1 input clause by four length-3 input clauses) only involve polynomial-time computations. Hence, it suffices to just work with 3-SAT decision problems with input clauses having exactly 3 distinct variables.</li>
</ul>
<p>Definition: The assignment solution &lt;P1, P2, P3, . . ., Pn&gt; is the term-wise falsification of the clause Pi1 Ú Pi2 Ú Pi3 Ú . . . Ú Pin if and only if for all natural number j, 1 £ j £ n: Pj = “True” if Pij = “~Pj” (Pj is negated in the clause);</p>
<pre>
  = “False”        if   Pij =  “Pj”   (Pj is not negated in the clause).
</pre>
<ul>
<li>For example, the assignment solution &lt;True, False, False&gt; is the term-wise falsification of the clause ~P1 Ú P2 Ú P3. The clause evaluates to False upon the substitution of the assignment solution’s truth-values — that is, the former is not satisfied by the latter.</li>
</ul>
<p>Theorem 2: For any natural number n ³ 1, every valid assignment solution to an n-CNF-SAT problem (that is, a CNF-SAT problem whose input clauses use exactly n variables) is simply the term-wise falsification of a clause that was not specified among its input clauses.</p>
<p>Proof: First, we observe that, for n variables, there are at most 2n possible clauses Ci = Pi1 Ú Pi2 Ú Pi3 Ú . . . Ú Pin , 1 £ i £ 2n that could be set up and there are the same maximum number 2n of possible assignment solutions &lt;P1, P2, P3, . . ., Pn&gt; to the n-CNF-SAT decision problem.</p>
<p>Next, we emphasize that each assignment solution &lt;P1, P2, P3, . . ., Pn&gt; satisfies all the 2n possible clauses except for one clause— its term-wise falsified clause. This is easily deduced from the following facts:</p>
<ul>
<li>The truth-value of P1 satisfies half (that is, 2n-1) of all the 2n possible clauses;</li>
<li>The truth-value of P2 satisfies half (that is, 2n-2) of all the 2n-1 possible clauses not satisfied by P1;</li>
<li>The truth-value of P3 satisfies half (that is, 2n-3) of all the 2n-2 possible clauses not satisfied by P1 and P2;</li>
</ul>
<p>. . .</p>
<ul>
<li>The truth-value of Pn-1 satisfies half (that is, 2) of all the 22 = 4 possible clauses not satisfied by P1, P2, P3, . . ., and Pn-2;</li>
<li>The truth-value of Pn satisfies half (that is, 1) of all the 21 = 2 possible clauses not satisfied by P1, P2, P3, . . ., and Pn-1; and</li>
<li>The sole possible clause not satisfied by the assignment solution &lt;P1, P2, P3, . . ., Pn&gt; is simply its term-wise falsified clause.</li>
</ul>
<p>Therefore, for every possible clause that was not specified in the input, we could obtain a valid assignment solution &lt;P1, P2, P3, . . , Pn&gt; — which is just the term-wise falsification of that unused clause in the CNF formula.</p>
<p>A simple computer program implementation of the above algorithm for finding a valid assignment solution &lt;P1, P2, P3, . . , Pn&gt; to an n-CNF-SAT decision problem might proceed as follows:</p>
<ul>
<li>For each n-CNF-SAT (n = 1, 2, 3, . . .) decision problem, the 2n possible clauses are assigned code numbers using the prime natural numbers and the all-clause-codes-product n-ACCP is evaluated.</li>
</ul>
<ul>
<li>
<ul>
<li>The standard clause code assignment tables are:</li>
</ul>
</li>
</ul>
<pre>
       Variables     Clause               Code
       ---------        ---------------        --—–
         n = 1            Pi                     2
                         ~Pi                     3
         n = 2            Pi Ú  Pj               5
</pre>
<p>Pi Ú ~Pj 7</p>
<pre>
                    ~Pi Ú  Pj              11
                         ~Pi Ú ~Pj              13
         n = 3            Pi Ú  Pj Ú  Pk        17
                          Pi Ú  Pj Ú ~Pk        19
</pre>
<p>Pi Ú ~Pj Ú Pk 23 Pi Ú ~Pj Ú ~Pk 29 ~Pi Ú Pj Ú Pk 31 ~Pi Ú Pj Ú ~Pk 37 ~Pi Ú ~Pj Ú Pk 41 ~Pi Ú ~Pj Ú ~Pk 43</p>
<ul>
<li>
<ul>
<li>
<ul>
<li>For very large n, the n-ACCP could be an extremely large number. It is stressed that the use of the prime natural numbers for clause code is just to ensure simple prime factorization of the clause codes product. Hence, we could also use character-type string clause codes instead of prime numbers, string concatenation instead of number multiplication, string deletion instead of number division, and in-string comparison for divisibility test.</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>The input-clause-codes-product ICCP is computed by multiplying the prime number clause codes of all the given input clauses.</li>
</ul>
<ul>
<li>The constant all-clause-codes-product n-ACCP is divided by the input-clause-codes-product ICCP and the distinct prime factors of the quotient are delineated (for a 3-SAT problem, the prime factorization here merely involves tests for divisibility by the first 21 + 22 + 23 = 14 prime natural numbers) — the latter identifies all the possible clauses that were excluded or not specified as input clauses.</li>
</ul>
<ul>
<li>Each valid assignment solution is readily obtained from the term-wise falsification of each excluded clause.</li>
</ul>
<p>Suppose a given 3-CNF-SAT problem has the following input clauses:</p>
<ul>
<li>C1 = P1 Ú P2 Ú P3 [17]</li>
<li>C2 = P1 Ú ~P2 Ú P3 [23]</li>
<li>C3 = ~P1 Ú P2 Ú P3 [31]</li>
<li>C4 = ~P1 Ú P2 Ú ~P3 [37]</li>
<li>C5 = ~P1 Ú ~P2 Ú P3 [41]</li>
</ul>
<p>Then, the input-clause codes-product ICCP = 17 • 23 • 31 • 37 • 41. Therefore,</p>
<pre>
    3-ACCP   17 • 19 • 23 • 29 • 31 • 37 • 41 • 43
    ------–  =  ---------------------------------------
     ICCP                17 • 23 • 31 • 37 • 41
</pre>
<pre>
             =  19 • 29 • 43
      
</pre>
<p>— so the excluded clauses and their respective assignment solutions are:</p>
<pre>
       Code         Excluded Clause      Assignment Solution
       ————     -----------------    ----------------------
        19       P1 Ú  P2 Ú ~P3     &lt; False, False, True &gt;
        29       P1 Ú ~P2 Ú ~P3     &lt; False, True, True &gt;
        43      ~P1 Ú ~P2 Ú ~P3     &lt; True, True, True &gt;
</pre>
<p>Definition: The assignment solution &lt;Pa, Pb, . . ., Pk&gt; to a k-CNF-SAT problem is a sub-solution of the assignment solution &lt;P1, P2, P3, . . ., Pn&gt; to its parent n-CNF-SAT decision problem if and only if {Pa, Pb, Pc, . . ., Pk} Í {P1, P2, P3, . . ., Pn}.</p>
<p>Theorem 3: Every valid assignment solution &lt;P1, P2, P3, . . ., Pn&gt; to a 3-SAT decision problem is simply a consistent (that is, it is not self-contradictory variable-truth-value-wise) union of one valid group-assignment-solution &lt;Pa&gt;, &lt;Pa, Pb&gt;, or &lt;Pa, Pb, Pc&gt; from every group of input clause(s) which involve the same 1, 2 or 3 variable(s).</p>
<p>The number theory concepts of divisibility and greatest common divisor of 2 or more natural numbers a, b, c, . . ., n —</p>
<pre>
    a|b   if and only if   b = aq   for some natural number q;
    d = gcd(a,b)   if and only if   d|a, d|b and (c|a Ù c|b) ® (c|d);
    gcd(a,b,c,...,n) = gcd(gcd((gcd(a,b),c),...),n)
</pre>
<p>— could be promptly invoked to easily establish the formation, from the valid group-assignment-solutions to the groups of input clause(s) which involves the same 1, 2 or 3 variable(s), of appropriate sub-solutions to a valid assignment solution to a 3-SAT decision problem.</p>
<ul>
<li>Let P1T, P1F, P2T, P2F, . . ., PnT, PnF be the respective prime natural number literal code to every one of the 2n possible truth-values of the n variables of a 3-SAT decision problem.</li>
</ul>
<ul>
<li>For each valid group-assignment-solution of every group, let us form a product of prime number literal codes by multiplying the actual prime number literal code(s) of all the variable(s) used in the group-solution and the 2 possible prime natural number literal codes of all the other unused variables in the said group-solution.</li>
</ul>
<ul>
<li>
<ul>
<li>The computations of products of prime number literal codes is not compulsory — it is proffered simply to make straightforward the determination of divisibility and the greatest common divisor among the group-assignment-solutions — that is, just to avoid the cumbersome conditionals of verifying the existence of 1 or 2 common variable(s) between two group-assignment-solutions of 2 different groups of input clause(s) with the same 1, 2 or 3 variable(s) before evaluating their divisibility status.</li>
</ul>
</li>
</ul>
<ul>
<li>
<ul>
<li>An alternate way to compute the product of prime number literal codes for each group-assignment-solution is to keep the constant all-literal-codes-product — n-ALCP = P1T•P1F•P2T•P2F•P3T•P3F• . . .•PnT•PnF — and then dividing it by the prime number literal code(s) of each variable in the excluded clause — that is, by PjF if Pj is negated, and by PjT if Pj is not negated, in the excluded clause.</li>
</ul>
</li>
</ul>
<ul>
<li>
<ul>
<li>For the groups of length-k (1 £ k £ 3) input clauses, this entails 2n – k factors for the product of prime number literal codes — for very large n, this could be an extremely large number. It is reemphasized that the use of prime natural numbers for literal codes is just to ensure simple prime factorization of the literal codes product. Therefore, we could also use character-type string literal codes instead of numeric-type prime numbers, string concatenation instead of number multiplication, string deletion instead of number division, as well as in-string comparison for divisibility test.</li>
</ul>
</li>
</ul>
<ul>
<li>As already noted earlier, for a 3-SAT problem with n variables, there are at most nC1 = n!/1!(n-1)! = n groups of single variable clauses with a maximum of 21 – 1 = 1 group-assignment-solution per group, and a maximum of nC2 = n!/2!(n-2)! = n(n-1)/2 groups of input clauses having the same 2 variables with at most 22 – 1 = 3 group-assignment-solutions per group, and at most nC3 = n!/3!(n-3)! = n(n-1)(n-2)/6 groups of input clauses having the same 3 variables with at most 23 – 1 = 7 group-assignment-solutions per group.</li>
</ul>
<ul>
<li>
<ul>
<li>In hindsight, the number of possible combinations of 1 group-assignment-solution from each group is of the order 7 raised to the exponent n3 — that is, to find all valid assignment solutions to a 3-SAT problem from its group-assignment-solutions would appear to involve exponential time computations. However, our simple algorithm straightforwardly constructs all of the possible assignment solutions to a 3-SAT problem — that is, it does not back up to try other combinations of group-assignment-solutions — and, at the ending of the verily deterministic polynomial-time procedure, categorically concludes that either there is no valid assignment solution to the parent 3-SAT decision problem or it definitely identifies all of them. Moreover, our algorithm stops forthrightly — that is, it does not have to continue the process — when it determines fatal inconsistencies between all the valid group-assignment-solutions of 2 groups of input clauses.</li>
</ul>
</li>
</ul>
<ul>
<li>
<ul>
<li>Following Theorem 3, we could readily ascertain that no valid assignment solution to the 3-SAT decision problem could come up if all the group-assignment-solution(s) to some group of input clause(s) with the same 1, 2 or 3 variable(s) are inconsistent with all group-assignment-solution(s) to at least one of the other group of input clause(s) with which the former group shares 1 or 2 variable(s). Hence, to establish that a 3-SAT decision problem has no valid assignment solution, it is sufficient to look at a group of input clause(s) (for ease, one takes the group with the least number of group-assignment-solutions) and to check that none of the latter’s group-assignment-solutions divides at least 1 of the group-assignment-solutions of a different group of input clause(s) with which the former group has a common 1 or 2 variable(s).</li>
</ul>
</li>
</ul>
<ul>
<li>
<ul>
<li>Using the products of prime number literal codes, the procedure is highly simplified because we could take advantage of the fact that the greatest common divisor of some set of natural numbers divides every natural-number-element of the given set and if their greatest common divisor consists of exactly n prime natural number factors — representing 1 prime number literal code for the actual truth-value of each variable — then we have also found a valid assignment solution to the parent 3-SAT problem.</li>
</ul>
</li>
</ul>
<ul>
<li>
<ul>
<li>Because there are at most O(n3) of group-assignment-solutions, then there are only a maximum of O(n3) evaluations of greatest common divisors — therefore, our algorithm certainly involves only polynomial-time computations. As a matter of fact, because there are at most 2n - 1 factors in the product of prime number literal codes (which is the starting greatest common divisor) and considering a realistic reduction of 1 prime number factor for each computation of greatest common divisors between groups, then it would take only O(n–1) calculations of greatest common divisors until a greatest common divisor with exactly n prime number factors is attained.</li>
</ul>
</li>
</ul>
<ul>
<li>Beginning from a group A of input clauses having the same 1, 2 or 3 variables with the least number g of valid group-assignment-solutions, its products of prime number literal codes are set up as initial greatest common divisors gcd1a (1 £ a £ g).</li>
</ul>
<ul>
<li>
<ul>
<li>For each product of prime number literal codes PPNLC2b from the second group B of input clauses with the least number g, or next least number h, of group-assignment-solutions, its greatest common divisor gcd2b (1 £ b £ g|h) with every gcd1a is evaluated — this only involves g2 or g ´ h computations. Because we had intentionally used prime natural numbers for literal codes, it is easier to compute the greatest common divisors gcdab(gcd1a,PPNLC2b) by simultaneous divisibility tests by the first 2n prime numbers of both gcd1a and PPNLC2b instead of, say, Euclid’s algorithm. If, for some j &lt; n, both PjT and PjF do not divide both gcd1a and PPNLC2b, then we already know that this particular gcdab is inconsistent so we do not have to continue with the divisibility tests for the rest of the prime number literal codes for this instance of gcdab and it is simply discarded.</li>
</ul>
</li>
</ul>
<ul>
<li>
<ul>
<li>If no gcdab has at least 1 of the 2 prime number literal codes for each variable dividing it, then the 2 groups have inconsistent group-assignment-solutions so, by Theorem 3, no combination of their group-assignment-solutions could both be sub-solutions of the same valid assignment solution to the parent 3-SAT decision problem. Our decision algorithm stops here with the definite conclusion that the original 3-SAT problem has no valid assignment solution.</li>
</ul>
</li>
</ul>
<ul>
<li>
<ul>
<li>All the gcdab that are inconsistent greatest common divisors are discarded. For every gcdab with at least 1 of the 2 prime number literal codes for each variable as factors, its greatest common divisors gcdabc with every product of prime number literal codes PPNLC3c from the next group C of input clauses with the least or next least number of group-solutions are computed.</li>
</ul>
</li>
</ul>
<ul>
<li>
<ul>
<li>Unless a fatal inconsistency ensued for some group G of input clauses — that is, if there is no gcdabc...g with at least 1 of the 2 prime number literal codes for each variable as factors — the immediately preceding steps are repeated for all the z groups of input clauses. Once a greatest common divisor gcdabc...g with exactly n prime number literal codes factors had been reached, then it is better to simply test for divisibility by gcdabc...g the products of prime number literal codes of the succeeding groups.</li>
</ul>
</li>
</ul>
<ul>
<li>In the end, every gcdabc...z with exactly n prime number factors — that is, P1X • P2X • P3X • . . . • PnX (X Î {“T”,“F”}), one for each truth-value of every variable Pj (1 £ j £ n) — decoded for their actual truth-values, absolutely provides a valid assignment solution &lt;P1, P2, P3, . . ., Pn&gt; to the original 3-SAT decision problem.</li>
</ul>
<ul>
<li>
<ul>
<li>We reiterate that our simple algorithm is truly deterministic and verily involves only polynomial-time computations — since we invoked prime number clause and literal codes, our calculations of greatest common divisors and prime number factorization are straightforward divisibility tests of the first 2n prime numbers.</li>
</ul>
</li>
</ul>
<ul>
<li>
<ul>
<li>Moreover, our simple algorithm not only decides the satisfiability of the input clauses of a given 3-SAT problem, it returns all the valid assignment solutions.</li>
</ul>
</li>
</ul>
<p>We can now summarize our simple polynomial-time algorithm [implemented as a relational database management system (RDBMS) application program that uses the standard Structured Query Language] for deciding a given 3-SAT problem as follows:</p>
<ul>
<li>The following prime number literal code assignments are labeled to the possible truth-values of each variable Pj, 1 £ j £ n:</li>
</ul>
<pre>
    Pj = “True”    assign the (2j – 1)th prime number as PjT; and
         = “False”      assign the (2j)th prime number as PjF.
</pre>
<p>Thus: P1T = 2, P1F = 3, P2T = 5, P2F = 7, P3T = 11, P3F = 13, etc.</p>
<ul>
<li>The 3-SAT problem input clauses are entered into a database table Input_Clauses_Table with two fields:</li>
</ul>
<ul>
<li>
<ul>
<li>Group_ID — a character-type data field of comma-delimited name(s) of the variable(s) involved in the particular input clause [this is an index field]; and</li>
</ul>
</li>
</ul>
<ul>
<li>
<ul>
<li>Clause_Code — a numeric-type data field of the standard prime number clause code for the form of the particular input clause.</li>
</ul>
</li>
</ul>
<ul>
<li>With just one SQL SELECT command on the Input_Clauses_Table records — following the simple polynomial-time algorithm presented earlier to find all of the respective valid group-assignment-solutions &lt;Pa&gt; or &lt;Pa, Pb&gt; or &lt;Pa, Pb, Pc&gt; to each group of the-same-1|2|3-variable(s) input clause(s) of the given 3-SAT decision problem with n variables — a Group_Assignment_Solutions_Table database table is readily created with the following fields in addition to Group_ID:</li>
</ul>
<ul>
<li>
<ul>
<li>Group_Solution — a numeric-type data field of the product of the prime number literal code of the actual truth-value of each variable in the term-wise-falsification of each excluded clause of every group of input clause(s) with the same 1, 2 or 3 variable(s);</li>
</ul>
</li>
</ul>
<ul>
<li>
<ul>
<li>Product_of_Prime_Number_Literal_Codes — a numeric-type data field of product of the actual prime number literal code(s) of all the variable(s) in the value of the Group_Solution field and the 2 possible prime number literal codes of all the other unused variables in the Group_Solution field value.</li>
</ul>
</li>
</ul>
<ul>
<li>The group(s) in the Group_Assignment_Solutions_Table with only 1 valid group-assignment-solution record already have fixed assigned truth-value(s) for the variable(s) in their respective Group_ID field value(s) so they can be used to purge the inconsistent-to-them records from Group_Assignment_Solutions_Table. Hence, every record in Group_Assignment_Solutions_Table whose value for its Product_of_Prime_Number_Literal_Codes field is not divisible by the value of the Group_Solution field of sole-record group(s) in the Group_Assignment_Solutions_Table are to be deleted. If the purged Group_Assignment_Solutions_Table contains new sole-record group(s), then the deletion of inconsistent-to-them records continue for the new single-record group(s).</li>
</ul>
<ul>
<li>For every record of the first group with the same Group_ID in the database table Group_Assignment_Solutions_Table, a respective Possible_3_SAT_Assignment_Solution_Table_Number database table is created with the following field in addition to Group_ID and Product_of_Prime_Number_Literal_Codes:</li>
</ul>
<ul>
<li>
<ul>
<li>Current_Greatest_Common_Divisor — a numeric-type data field for the recurrently computed greatest common divisor.</li>
</ul>
</li>
</ul>
<ul>
<li>
<ul>
<li>
<ul>
<li>The Possible_3_SAT_Assignment_Solution_Table_Number table correspondingly records the possible sub-solutions that made up a valid assignment solution to the parent 3-SAT decision problem — if this information is not desired, then this table could be dispensed with.</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>
<ul>
<li>
<ul>
<li>Each Possible_3_SAT_Assignment_Solution_Table_Number has a respective initial record corresponding to the record(s) of the first group in the database table Group_Assignment_Solutions_Table with the Product_of_Prime_Number_Literal_Codes field’s value also assigned at first as the Current_Greatest_Common_Divisor field’s value.</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>A database table Greatest_Common_Divisors_Table is also created with this field in addition to Current_Greatest_Common_Divisor:</li>
</ul>
<ul>
<li>
<ul>
<li>Possible_3_SAT_Assignment_Solution_Table_Reference — a character-type data field for the actual name of the table Possible_3_SAT_Assignment_Solution_Table_Number that involves the Current_Greatest_Common_Divisor field value. [If Possible_3_SAT_Assignment_Solution_Table_Number database tables are dispensed with, then so must this field be.]</li>
</ul>
</li>
</ul>
<ul>
<li>
<ul>
<li>
<ul>
<li>The database table Greatest_Common_Divisors_Table keeps track of the computed greatest common divisors that remain feasible to provide a valid assignment solution to the 3-SAT decision problem.</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>
<ul>
<li>
<ul>
<li>Corresponding to each record of the first group in the database table Group_Assignment_Solutions_Table, or corresponding to every Possible_3_SAT_Assignment_Solution_Table_Number database table’s initial record, a matching related record in the database table Greatest_Common_Divisors_Table is also initially inputted.</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>For each Product_of_Prime_Number_Literal_Codes field’s value, of every record in the second group of group-assignment-solutions in the Group_Assignment_Solutions_Table, their greatest common divisors with the Current_Greatest_Common_Divisor field’s value of all the records in the Greatest_Common_Divisors_Table are evaluated. If there is no fatal inconsistencies, then the process is repeated for each succeeding group of group-assignment-solutions in the Group_Assignment_Solutions_Table.</li>
<li>If the procedure is completed for all the groups of group-assignment-solutions in the Group_Assignment_Solutions_Table without any fatal inconsistency, then every Current_Greatest_Common_Divisor field’s value of each record that remained in the database table Greatest_Common_Divisors_Table provides, after its appropriate decoding, a valid assignment solution to the 3-SAT decision problem.</li>
</ul>
<p>BenCawaling@Yahoo.com [12 July 2005]</p>
<ul>
<li>Your text is all screwed up. Maybe it would be a better idea to publish a pdf with this. Have you implemented tried implementing this algorithm? Do you trust it? <a href="../../../r/b/a/User%7ERbarreira_44f4.html" title="User:Rbarreira">Rbarreira</a> 17:06, 13 July 2005 (UTC)</li>
</ul>
<dl>
<dd>There are several problems with this argument, and I thank you for not adding it immediately to the article. Here are a few of its problems:
<ul>
<li><i>Next, we emphasize that each assignment solution &lt;P1, P2, P3, . . ., Pn&gt; satisfies all the 2n possible clauses except for one clause— its term-wise falsified clause.</i></li>
</ul>
</dd>
<dd>This is true, but only in reference to the universe of all clauses of length <i>n</i>, where <i>n</i> is the number of variables, of which there are 2<sup>n</sup>. The clauses in the input are usually much shorter, and if you were to extend them all to <i>n</i> variables, there would be exponentially many clauses. This amounts to enumerating all assignments which fail to satisfy.
<ul>
<li><i>Therefore, for every possible clause that was not specified in the input, we could obtain a valid assignment solution &lt;P1, P2, P3, . . , Pn&gt; — which is just the term-wise falsification of that unused clause in the CNF formula. [...] Each valid assignment solution is readily obtained from the term-wise falsification of each excluded clause.</i></li>
</ul>
</dd>
<dd>That's not true at all - many of the "unused"/"excluded" clauses are <i>implied by</i> the input clauses. A good example is the formula for the pigeonhole problem, where an <i>exponential</i> number of clauses not in the input are implied by the clauses in the input. The algorithm would be trivial if it sufficed to locate a clause not given in the input.</dd>
<dd>The prime-based encoding seems like it might be a good idea, although I didn't look at it too closely (I stopped at the above part), but I don't think this algorithm can be saved. <a href="../../../d/c/o/User%7EDcoetzee_a2a7.html" title="User:Dcoetzee">Deco</a> 17:37, 13 July 2005 (UTC)</dd>
</dl>
<dl>
<dd>Yes, thank you for not adding it immediately to the article. Some major problems:
<ul>
<li>It is <i>very hard</i> to understand the algorithm in terms of SQL.</li>
<li>Every "theorem" is trivial, and well-known, for example, Theorem 1 follows from the definition of the resolution proof system, it is better just add links to papers/books where there are proved.</li>
<li>The algorithm uses exponential amount of memory for the product of all assignments for <span class="texhtml"><i>n</i></span> variables. So it is not polynomial time algorithm.</li>
</ul>
</dd>
<dd>It is very easy to test any algorithm with help of benchmarks from <a href="http://www.satlib.org" class="external text" title="http://www.satlib.org" rel="nofollow">SatLib</a>  ;) --<a href="../../../a/r/i/User%7EAristk_5f42.html" title="User:Aristk">Aristk</a> 13:15, 14 July 2005 (UTC)</dd>
</dl>
<dl>
<dd>The prime based encoding is merely a (tortured) representation that permits use of division, multiplication &amp; gcd in place of boolean operations, *increasing* the complexity of a solution. That leaves only the last 2 sentences as relevant to the "method", which doesn't work. The iterative process described, if implemented so that it generates a correct answer in the "gcd" table requires 2^n operations and just as many rows in the table. In other words, exactly what the method was supposed to avoid. This is obviously a crank proof. The original author is no where to be found, and it seems to me he tried it with 7 variables (a-g), which because of the representation structure, just happens to iterate to a correct solution. I vote that it be deleted.</dd>
</dl>
<p><a href="../../../j/o/k/User%7EJok2000_bdd4.html" title="User:Jok2000">Jok2000</a> 23:06, 11 October 2005 (UTC)</p>
<dl>
<dd>The proof of P=NP, regardless of correctness, has not been published anywhere else. If correct, it should be first published in a computer science journal, not in an encyclopedia (see <a href="../../../n/o/r/WP%7ENOR_e27a.html" title="WP:NOR">WP:NOR</a>). Even the talk page is in this case an inappropriate place for it. However, deleting is may be confusing because old versions of the pages are always accessible. I added a box at beginning of the proof saying that this proof has not been endorsed by anyone else beside the (anonymous) author, that some editors think it is flakey, and that this is not the place for publishing original reaseach to begin with. Paolo Liberatore (<a href="../../../p/a/o/User_talk%7EPaolo_Liberatore_53e0.html" title="User talk:Paolo Liberatore">Talk</a>) 11:23, 12 October 2005 (UTC)</dd>
</dl>

<div class="printfooter">
Retrieved from "<a href="http://en.wikipedia.org../../../b/o/o/Talk%7EBoolean_satisfiability_problem_Archive_1_8d0a.html">http://en.wikipedia.org../../../b/o/o/Talk%7EBoolean_satisfiability_problem_Archive_1_8d0a.html</a>"</div>
	    <div id="catlinks"><p class='catlinks'><a href="../../../c/a/t/Special%7ECategories_101d.html" title="Special:Categories">Category</a>: <span dir='ltr'><a href="../../../t/a/l/Category%7ETalk_archives_8451.html" title="Category:Talk archives">Talk archives</a></span></p></div>	    <!-- end content -->
	    <div class="visualClear"></div>
	  </div>
	</div>
      </div>
      <div id="column-one">
	<div id="p-cactions" class="portlet">
	  <h5>Views</h5>
	  <ul>
	    <li id="ca-nstab-main"
	       	       ><a href="../../../b/o/o/Boolean_satisfiability_problem_Archive_1_2895.html">Article</a></li><li id="ca-talk"
	       class="selected"	       ><a href="../../../b/o/o/Talk%7EBoolean_satisfiability_problem_Archive_1_8d0a.html">Discussion</a></li><li id="ca-current"
	       	       ><a href="http://en.wikipedia.org/wiki/Talk:Boolean_satisfiability_problem/Archive_1">Current revision</a></li>	  </ul>
	</div>
	<div class="portlet" id="p-logo">
	  <a style="background-image: url(../../../images/wiki-en.png);"
	    href="../../../index.html"
	    title="Main Page"></a>
	</div>
	<script type="text/javascript"> if (window.isMSIE55) fixalpha(); </script>
		<div class='portlet' id='p-navigation'>
	  <h5>Navigation</h5>
	  <div class='pBody'>
	    <ul>
	    	      <li id="n-Main-page"><a href="../../../index.html">Main page</a></li>
	     	      <li id="n-Contents"><a href="../../../c/o/n/Wikipedia%7EContents_3181.html">Contents</a></li>
	     	      <li id="n-Featured-content"><a href="../../../f/e/a/Wikipedia%7EFeatured_content_24ba.html">Featured content</a></li>
	     	      <li id="n-currentevents"><a href="../../../c/u/r/Portal%7ECurrent_events_bb60.html">Current events</a></li>
	     	    </ul>
	  </div>
	</div>
		<div class='portlet' id='p-interaction'>
	  <h5>interaction</h5>
	  <div class='pBody'>
	    <ul>
	    	      <li id="n-About-Wikipedia"><a href="../../../a/b/o/Wikipedia%7EAbout_8d82.html">About Wikipedia</a></li>
	     	      <li id="n-portal"><a href="../../../c/o/m/Wikipedia%7ECommunity_Portal_6a3c.html">Community portal</a></li>
	     	      <li id="n-contact"><a href="../../../c/o/n/Wikipedia%7EContact_us_afd6.html">Contact us</a></li>
	     	      <li id="n-sitesupport"><a href="http://wikimediafoundation.org/wiki/Fundraising">Make a donation</a></li>
	     	      <li id="n-help"><a href="../../../c/o/n/Help%7EContents_22de.html">Help</a></li>
	     	    </ul>
	  </div>
	</div>
		<div id="p-search" class="portlet">
	  <h5><label for="searchInput">Search</label></h5>
	  <div id="searchBody" class="pBody">
	    <form action="javascript:goToStatic(3)" id="searchform"><div>
	      <input id="searchInput" name="search" type="text"
	        accesskey="f" value="" />
	      <input type='submit' name="go" class="searchButton" id="searchGoButton"
	        value="Go" />
	    </div></form>
	  </div>
	</div>
	      </div><!-- end of the left (by default at least) column -->
      <div class="visualClear"></div>
      <div id="footer">
    <div id="f-poweredbyico"><a href="http://www.mediawiki.org/"><img src="../../../skins/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" /></a></div>	<div id="f-copyrightico"><a href="http://wikimediafoundation.org/"><img src="../../../images/wikimedia-button.png" border="0" alt="Wikimedia Foundation"/></a></div>	<ul id="f-list">
	  	  	  <li id="f-credits">This page was last modified 16:40, 21 December 2006 by Wikipedia user <a href="../../../g/u/r/User%7EGurchBot_2_2218.html" title="User:GurchBot 2">GurchBot 2</a>. Based on work by Wikipedia user(s) <a href="../../../g/u/r/User%7EGurch_e84c.html" title="User:Gurch">Gurch</a> and <a href="../../../t/i/z/User%7ETizio_edab.html" title="User:Tizio">Tizio</a>.</li>	  <li id="f-copyright">All text is available under the terms of the <a class='internal' href="../../../t/e/x/Wikipedia%7EText_of_the_GNU_Free_Documentation_License_702a.html" title="Wikipedia:Text of the GNU Free Documentation License">GNU Free Documentation License</a>. (See <b><a class='internal' href="../../../c/o/p/Wikipedia%7ECopyrights_92c4.html" title="Wikipedia:Copyrights">Copyrights</a></b> for details.) <br /> Wikipedia&reg; is a registered trademark of the <a href="http://www.wikimediafoundation.org">Wikimedia Foundation, Inc</a>., a US-registered <a class='internal' href="../../../5/0/1/501%28c%29.html#501.28c.29.283.29" title="501(c)(3)">501(c)(3)</a> <a href="http://wikimediafoundation.org/wiki/Deductibility_of_donations">tax-deductible</a> <a class='internal' href="../../../n/o/n/Non-profit_organization.html" title="Non-profit organization">nonprofit</a> <a href="../../../c/h/a/Charitable_organization.html" title="Charitable organization">charity</a>.<br /></li>	  <li id="f-about"><a href="../../../a/b/o/Wikipedia%7EAbout_8d82.html" title="Wikipedia:About">About Wikipedia</a></li>	  <li id="f-disclaimer"><a href="../../../g/e/n/Wikipedia%7EGeneral_disclaimer_3e44.html" title="Wikipedia:General disclaimer">Disclaimers</a></li>	  	</ul>
      </div>
    </div>
  </body>
</html>
