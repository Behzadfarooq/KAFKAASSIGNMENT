<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    		<meta name="keywords" content="Talk:Binary search algorithm,Dcoetzee,Deco,Dze27,Ieopo,Lkesteloot,Robocoder,Solidpoint,NickyMcLean,J4 james,131.230.133.185" />
		<link rel="shortcut icon" href="/favicon.ico" />
		<link rel="search" type="application/opensearchdescription+xml" href="/w/opensearch_desc.php" title="Wikipedia (English)" />
		<link rel="copyright" href="../../../COPYING.html" />
    <title>Talk:Binary search algorithm - Wikipedia, the free encyclopedia</title>
    <style type="text/css">/*<![CDATA[*/ @import "../../../skins/htmldump/main.css"; /*]]>*/</style>
    <link rel="stylesheet" type="text/css" media="print" href="../../../skins/common/commonPrint.css" />
    <!--[if lt IE 5.5000]><style type="text/css">@import "../../../skins/monobook/IE50Fixes.css";</style><![endif]-->
    <!--[if IE 5.5000]><style type="text/css">@import "../../../skins/monobook/IE55Fixes.css";</style><![endif]-->
    <!--[if IE 6]><style type="text/css">@import "../../../skins/monobook/IE60Fixes.css";</style><![endif]-->
    <!--[if IE]><script type="text/javascript" src="../../../skins/common/IEFixes.js"></script>
    <meta http-equiv="imagetoolbar" content="no" /><![endif]-->
    <script type="text/javascript" src="../../../skins/common/wikibits.js"></script>
    <script type="text/javascript" src="../../../skins/htmldump/md5.js"></script>
    <script type="text/javascript" src="../../../skins/htmldump/utf8.js"></script>
    <script type="text/javascript" src="../../../skins/htmldump/lookup.js"></script>
    <script type="text/javascript" src="../../../raw/gen.js"></script>        <style type="text/css">/*<![CDATA[*/
@import "../../../raw/MediaWiki%7ECommon.css";
@import "../../../raw/MediaWiki%7EMonobook.css";
@import "../../../raw/gen.css";
/*]]>*/</style>          </head>
  <body
    class="ns-1">
    <div id="globalWrapper">
      <div id="column-content">
	<div id="content">
	  <a name="top" id="contentTop"></a>
	        <h1 class="firstHeading">Talk:Binary search algorithm</h1>
	  <div id="bodyContent">
	    <h3 id="siteSub">From Wikipedia, the free encyclopedia</h3>
	    <div id="contentSub"></div>
	    	    <div class="usermessage">You have <a href="../../../1/2/7/User_talk%7E127.0.0.1.html" title="User talk:127.0.0.1">new messages</a> (<a href="../../../1/2/7/User_talk%7E127.0.0.1.html" title="User talk:127.0.0.1">last change</a>).</div>	    <!-- start content -->
	    <table id="toc" class="toc" summary="Contents">
<tr>
<td>
<div id="toctitle">
<h2>Contents</h2>
</div>
<ul>
<li class="toclevel-1"><a href="#Definition__Clarification.3F"><span class="tocnumber">1</span> <span class="toctext">Definition Clarification?</span></a></li>
<li class="toclevel-1"><a href="#Pseudo_code_change"><span class="tocnumber">2</span> <span class="toctext">Pseudo code change</span></a></li>
<li class="toclevel-1"><a href="#Bridging_ideas"><span class="tocnumber">3</span> <span class="toctext">Bridging ideas</span></a></li>
<li class="toclevel-1"><a href="#Real-world_programming_language_example"><span class="tocnumber">4</span> <span class="toctext">Real-world programming language example</span></a></li>
<li class="toclevel-1"><a href="#Recursive_Change"><span class="tocnumber">5</span> <span class="toctext">Recursive Change</span></a></li>
<li class="toclevel-1"><a href="#Pseudocode_examples_will_not_work"><span class="tocnumber">6</span> <span class="toctext">Pseudocode examples will not work</span></a></li>
<li class="toclevel-1"><a href="#Integer_Overflow"><span class="tocnumber">7</span> <span class="toctext">Integer Overflow</span></a></li>
<li class="toclevel-1"><a href="#Where_does_the_name_come_from.3F"><span class="tocnumber">8</span> <span class="toctext">Where does the name come from?</span></a></li>
<li class="toclevel-1"><a href="#This_page_needs_some_serious_work"><span class="tocnumber">9</span> <span class="toctext">This page needs some serious work</span></a></li>
</ul>
</td>
</tr>
</table>
<p><script type="text/javascript">
//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>
</script><a name="Definition__Clarification.3F" id="Definition__Clarification.3F"></a></p>
<h2><span class="editsection">[<a href="../../../b/i/n/Talk%7EBinary_search_algorithm_111d.html" title="Edit section: Definition  Clarification?">edit</a>]</span> <span class="mw-headline">Definition Clarification?</span></h2>
<p><a href="http://www.nist.gov/dads/HTML/suffixarray.html" class="external free" title="http://www.nist.gov/dads/HTML/suffixarray.html" rel="nofollow">http://www.nist.gov/dads/HTML/suffixarray.html</a></p>
<p>The reason I bring this up is because the opening definition of binary_search is because it doesn't include a clear definition "that characteristic" used by the "sort algorithm".The charicteristic used would be the order of the data, or the orderability of the data. [E.g. a "recent changes" page can be ordered alphabetically, or chronologically. This type data two inherently sequential properties, alpha and chron., both linear arrays] I'm neither a programmer nor mathematician....=/ Suffix array is something special, too. more on that</p>
<p>Posted in wiki: In computer science, binary search or binary chop is a search algorithm for finding a particular value in a list of data. A divide and conquer algorithm, binary search requires random access to the data being searched, the ability to quickly get the kth item in the list. In its simplest form, binary search assumes the data is sorted (usually by a sort algorithm) and takes advantage of that characteristic.</p>
<p><br /></p>
<p><a href="http://www.nist.gov" class="external free" title="http://www.nist.gov" rel="nofollow">http://www.nist.gov</a> Definition: Search a sorted array by repeatedly dividing the search interval in half. Begin with an interval covering the whole array. If the value of the search key is less than the item in the middle of the interval, narrow the interval to the lower half. Otherwise narrow it to the upper half. Repeatedly check until the value is found or the interval is empty. -links to- [is an example of a:]</p>
<pre>
dichotomic search definition: Search by selecting between two distinct alternatives (dichotomies) at each step. 
</pre>
<p><br /></p>
<p>Data Structures, Algorithms Binary Search Algorithm</p>
<p>This Binary Search Algorithm uses recursive subdivisions of an array to perform a search. Enter the size of the array in the text field, and click the "Create" button. The array is created with randomly generated numbers. Now, input a search key in the text field, and click the "Search" button. <a href="http://www.cosc.canterbury.ac.nz/people/mukundan/dsal/BSearch.html" class="external free" title="http://www.cosc.canterbury.ac.nz/people/mukundan/dsal/BSearch.html" rel="nofollow">http://www.cosc.canterbury.ac.nz/people/mukundan/dsal/BSearch.html</a></p>
<p><br />
These two definitions use the term ARRAY. Answers.com clears this up: ARRAY:</p>
<ol>
<li>Mathematics.</li>
</ol>
<pre>
  1. A rectangular arrangement of quantities in rows and columns, as in a matrix.
  2. Numerical data linearly ordered by magnitude.
</pre>
<ul>
<li>
<ul>
<li><a href="../../../i/e/o/User%7EIeopo_4c8f.html" title="User:Ieopo">Ieopo</a> 04:03, 28 October 2005 (UTC)</li>
</ul>
</li>
</ul>
<p><a name="Pseudo_code_change" id="Pseudo_code_change"></a></p>
<h2><span class="editsection">[<a href="../../../b/i/n/Talk%7EBinary_search_algorithm_111d.html" title="Edit section: Pseudo code change">edit</a>]</span> <span class="mw-headline">Pseudo code change</span></h2>
<p>I changed the pseudocode since it was incorrect.<a href="../../../d/z/e/User%7EDze27_8d23.html" title="User:Dze27">dze27</a></p>
<hr />
<p>Pseudocode:</p>
<pre>
function binary-search(L,V)
  set start = 1
  set end = N
  repeat while start &lt;= end
    set middle = (start + end) div 2
    if V = L[middle]
      return success    
    else-if V &lt; L[middle]
      set end = middle - 1 
    else-if (V &gt; L[middle])
      set start = middle + 1
    end-if
  end-repeat
  return failure
end-function

Notes: 
 div is integer division (discard any remainder)
</pre>
<hr />
<p>In practice, the non-recursive algorithm would be implemented with some minor changes: <a href="../../../r/o/b/User%7ERobocoder_9b81.html" title="User:Robocoder">Robocoder</a> 15:02, 12 November 2005 (UTC)</p>
<ul>
<li>To avoid overflowing (e.g., left+right &gt; maxint), calculate:</li>
</ul>
<pre>
mid := floor(left+(right-left)/2)
</pre>
<ul>
<li>Searching the top half of the array is implied and does not require the conditional test:</li>
</ul>
<pre>
<b>if</b> value &gt; a[mid]
</pre>
<dl>
<dd>In pseudocode we assume that integers are infinite-precision, for the sake of simplicity, but you are correct. Similarly, the redundant conditional test exists solely for clarity. Pseudocode is designed for people to read. <a href="../../../d/e/c/User%7EDeco_20f6.html" title="User:Deco">Deco</a> 21:53, 12 November 2005 (UTC)</dd>
</dl>
<hr />
<p><a name="Bridging_ideas" id="Bridging_ideas"></a></p>
<h2><span class="editsection">[<a href="../../../b/i/n/Talk%7EBinary_search_algorithm_111d.html" title="Edit section: Bridging ideas">edit</a>]</span> <span class="mw-headline">Bridging ideas</span></h2>
<p>Has anyone else noticed that the part with the example of guessing numbers between 1-16 and the part with the pseudocode etc, aren't very well connected? Someone who don't already know what binary search is, and how it works, might not make the connection?</p>
<p>Anyone have any ideas how to express how the _algorithm_ for 'guessing' the right number in the 'game' can be used to find the position of a certain number in a list?</p>
<dl>
<dd>Good point. I tried to add some transition and tie them in somewhat, but they're still a bit separated. I hope this helps. <a href="../../../d/c/o/User%7EDcoetzee_a2a7.html" title="User:Dcoetzee">Deco</a> 07:27, 26 Dec 2004 (UTC)</dd>
</dl>
<p>The pseudocode is pretty intense for me - it seems more complex than it may need to be. I think the number guessing game should include a formula* for finding for finding the smallest number of steps required to resolve any unknown number. [The "50 in 6 steps example" should be accented with a "100 in 7 steps example" to give scope of the power of the algorithm]</p>
<ul>
<li>Formula? I can't find the formula or make one - I keep coming up with more code than math [e.g. if NOT real number then]</li>
</ul>
<p><a name="Real-world_programming_language_example" id="Real-world_programming_language_example"></a></p>
<h2><span class="editsection">[<a href="../../../b/i/n/Talk%7EBinary_search_algorithm_111d.html" title="Edit section: Real-world programming language example">edit</a>]</span> <span class="mw-headline">Real-world programming language example</span></h2>
<p>I would as well appreciate an implementation form in a real-world programming language -- HJH</p>
<dl>
<dd>Wikipedia isn't a code repository. The pseudocode sufficiently explains the algorithm. Please search and insert an external link. — 131.230.133.185 01:37, 13 July 2005 (UTC)</dd>
</dl>
<dl>
<dd>
<dl>
<dd>At first I was quite alarmed by this change, mostly because the reason used to make the edit could be applied to unilateral deletion of code samples from all articles, which would be very bad and highly controversial. But in this particular case, I believe you're right — the samples are almost identical to the pseudocode in form and function. No need for redundancy. <a href="../../../d/c/o/User%7EDcoetzee_a2a7.html" title="User:Dcoetzee">Deco</a> 04:12, 13 July 2005 (UTC)</dd>
</dl>
</dd>
</dl>
<p><a name="Recursive_Change" id="Recursive_Change"></a></p>
<h2><span class="editsection">[<a href="../../../b/i/n/Talk%7EBinary_search_algorithm_111d.html" title="Edit section: Recursive Change">edit</a>]</span> <span class="mw-headline">Recursive Change</span></h2>
<p>I changed the code for the recursive version because it wouldn't have worked as written. The "return mid" statement would have returned the value to one of the recursive calls rather than the initial, external caller. 69.171.89.130 21:48, 4 February 2006 (UTC)</p>
<dl>
<dd>Right you are. Good catch. <a href="../../../d/e/c/User%7EDeco_20f6.html" title="User:Deco">Deco</a> 23:42, 4 February 2006 (UTC)</dd>
</dl>
<p><a name="Pseudocode_examples_will_not_work" id="Pseudocode_examples_will_not_work"></a></p>
<h2><span class="editsection">[<a href="../../../b/i/n/Talk%7EBinary_search_algorithm_111d.html" title="Edit section: Pseudocode examples will not work">edit</a>]</span> <span class="mw-headline">Pseudocode examples will not work</span></h2>
<p>hi, I think that the algorithm will not work if programmed as described in the pseudocode examples. The values of the right-variable are never checked if they are equal value. Therefore you can never find the value 'b' in the list 'a','b'.</p>
<dl>
<dd>I think you're incorrect. Because we add 1 to mid during each recursive call, it must continue to get larger with each call, so eventually the range will only contain "right". <a href="../../../d/e/c/User%7EDeco_20f6.html" title="User:Deco">Deco</a></dd>
</dl>
<p>It's possible to write this algorithm in a way that avoids special-case testing, and confusing indexing with a +1 here and perhaps not there. It would also be good to perform a single comparison at each stage (the actual comparison might be via function evaluation) though few computer languages enable this. Suppose an array <i>A</i>, with elements 1 to <i>N</i> to be searched to find an index <i>i</i> such that <i>A(i) = X</i>. In a pseudocode fragment, converted from a working programme written in accordance with Professor Knuth's version,</p>
<pre>
        L:=0;                             %Establish outer bounds.
        R:=N + 1;                         %One before, and one after, the first and last.
  Probe:P:=(R - L)/2;                     %Truncate to integer. Beware integer overflow with (L + R)/2.
        <b>if</b> P &lt;= 0 <b>then</b> <b>Return</b>(NotFound);  %Aha! Nowhere!
        P:=P + L;                         %Probe the middle of the span L:R.
        <b>Case</b> <b>Sign</b>(X - A(P))               %Perform the comparison once.
Positive:L:=P, <b>go to</b> Probe;               %Shift the left bound up:    X follows A(P).
Negative:R:=P, <b>go to</b> Probe;               %Shift the right bound down: X precedes A(P).
    Zero:<b>Return</b>(P);                       %So, X is found, here!       X equals A(P).
        <b>Otherwise</b>;                        %No other cases are possible.
</pre>
<p>Now then, this is not C, it is <i>pseudocode</i> so be brave. What I mean by <i>Case Sign(expression)</i> is to consider the sign of the expression's value, which has three cases. In most languages you are stuck with something like <i>if expression &gt; 0 then ... else if expression &lt; 0 then ... else ...;</i> or some such permutation of the three cases. This means that on average half the time, <i>two</i> comparisons with be performed at each stage, not one. But in fortran, you can write <i>IF (expression) negative,zero,positive</i> meaning <i>go to</i> the appropriate label for the three cases, and obviously, the expression is written (and hopefully, compiled to execute) once only.</p>
<p>Notice that there is no special case testing for annoyances such as <i>N = 0</i> or <i>N = 1</i>, or <i>X</i> being outside the bounds of <i>A(1)</i> to <i>A(N)</i>, which are particularly annoying to check if <i>N = 0</i>. These cases are all encompassed in the one method, and it is very easy to make mistakes with half-remembered details. Further, this code contains usage of the deprecated <i>go to</i> statement, but I invite those who recoil to present a revision that avoids wasted effort or replicated code and blather splattered across the page. NickyMcLean 21:07, 13 December 2006 (UTC)</p>
<p>Regarding NickyMcLean's broken changes from 19:33, 15 February 2007: A is a sorted list with range 1 to N. Consider a single item list (i.e. N=1): low will be initialsed to 0, high to 2 and the first probe, p, to 1. That is the only valid index in the list, and yet if that doesn't match the loop won't end. Your next set of values are either high=1, low still 0, and p=0 (out of bounds fault), or low=1, high still 2, and p still 1 (an infinite loop). The while condition MUST be (low &lt; high-1) for this form of the algorithm to work. j4_james 22:55, 15 February 2007 (UTC)</p>
<p>Yep, you're right, your fix for the C-pseudocode was correct and I misread it. In the above pseudocode the test remains the simple <i>P &lt;= 0</i> (to stop) rather than <i>low &lt; high - 1</i> (to continue) in the C-pseudocode formulation. Apologies for the burp in my skull sludge. NickyMcLean 00:00, 16 February 2007 (UTC) PS: Neat timestamp! And after I had lunch (2pm in NZ) I remembered how I coded the binary chopper in assembler.</p>
<p>I see that the C-pseudocode is still unstable, as Mariolj claims an error fixed if the sought item is not in the list. But after my previous mistake, I'm not going to look again! And all the time, the above pseudocode remains compact and correct, and is a slightly-edited copy from an actual working prog. which has worked correctly when confronted by a search for a value not in the list. But the pseudocode is not in the C-style... NickyMcLean 04:08, 21 February 2007 (UTC)</p>
<p>I can assure it's now broken again. There are two common forms of the algorithm - one with the low and high bounds outside the test range (start with low = 0 and high = N+1) and one with the bounds inside (start with low = 1 and high = N). The problem is that people tend to confuse the two which is how you end up with the disastrous hybrid that we have now. It's easy to prove that it's broken with a simple walk through of two elements. I couldn't care less what format the pseudocode is in, but it would have been nice if it worked. j4_james 19:15, 21 February 2007 (UTC)</p>
<p><a name="Integer_Overflow" id="Integer_Overflow"></a></p>
<h2><span class="editsection">[<a href="../../../b/i/n/Talk%7EBinary_search_algorithm_111d.html" title="Edit section: Integer Overflow">edit</a>]</span> <span class="mw-headline">Integer Overflow</span></h2>
<p>Prompted by MuthuKutty the remark "Beware integer overflow" can be expanded upon without adding further blather to the proffered pseudo-C. When writing pseudocode, it is usually supposed that any variable is capacious enough to encompass the largest value or greatest precision necessary for the method so that messy details will not obscure the technique, but in actual implementations there are limits, and they are close. Suppose 16-bit signed integers are used: clearly the indexing of the array will work only up to it having 32,767 elements. Alas, the calculation of P:=(R + L)/2; can fail long before that, because the sum can easily exceed the 16-bit limit as when the array has more than 16384 elements and the area being probed is close to the high end of the array. This can be fixed (<i>almost</i>) by making the expression slightly larger, and accepting the extra execution time: P:=(R - L)/2 + L; (This order has hope of slightly faster execution than L + (R - L)/2, since no temporary storage is needed to hold the value of L while the (R - L)/2 part is being computed)</p>
<p>But only <i>almost</i>. Suppose the array has indeed 32,767 elements. Now remember that the initial values of <i>L</i> and <i>R</i> are to be one outside the bounds, so <i>R</i> must be able to hold 32,768, and it can't in 16-bit signed integer form. Similarly, suppose that unsigned integers are to be used: all well and good, and the same problem exists with a maximal upper bound. But suppose that the array indexing starts with zero (as in C, by requirement) rather than one for whatever reason. The initial value of <i>L</i> is to be one less than the first index, and -1 is not a possible value for an unsigned integer.</p>
<p>A further possibility exists. Most computer languages do not offer a protocol for a three-way test on the result of a comparison so the code is usually some lame repetition of the comparison such as</p>
<pre>
  if A(P) &lt; X then L:=P
   else if A(P) &gt; X then R:=P
    else Return(P)
</pre>
<p>Suppose instead this is avoided via</p>
<pre>
  diff:=A(P) - X;
  if diff &lt; 0 then L:=P
   else if diff &gt; 0 then R:=P
    else Return(P)
</pre>
<p>With the hope that the compiler will optimise the repeated access of variable <i>diff</i> using some sort of temporary register. (A compiler is very unlikely to optimise the repeated comparison code, not least because the code is not <i>exactly</i> repeated; one has &lt; while the other has &gt;) Alas, if the comparison is performed on variables with limited capacity, such as integers, this can fail because the difference overflows the integer limit as in (for 16-bit) 30000 - (-15000). The explicit comparison code will (should!) succeed, because the compiler writer will (should!) have taken advantage of such machine indicators as overflow and carry which were set by the subtract operation, which states are not carried along into the value of variable <i>diff</i>. In the absence of a three-way test syntax, only assembler programming will produce good code. NickyMcLean 20:46, 12 February 2007 (UTC)</p>
<dl>
<dd>
<dl>
<dd>Nicky, look up bsearch() in the C Standard Libarary. There is no compare function. There is only a function pointer to a compare function. If you want to compare strings then use strcmp() and it will return 1, -1, 0. This exact same set of values must be returned by any comparison function called through the function pointer specified to bsearch() as a function having two void pointers as its arguement.</dd>
</dl>
</dd>
</dl>
<dl>
<dd>
<dl>
<dd>int CmpInt( int *piKey, int *piArrayMem) // bsearch() might complain about typing here</dd>
<dd>if *piKey &lt; *piArrayMem return -1; // any negative value is sufficient/legal</dd>
<dd>if *piKey &gt; *piArrayMem return +1; // any positive value is sufficinet/legal</dd>
<dd>return 0;</dd>
</dl>
</dd>
</dl>
<dl>
<dd>
<dl>
<dd>// for searching arrays of structs use a compare function like this</dd>
<dd>int CmpMyStruct( int *piKey, MyStruct *pArrayMem) // bsearch() might complain about typing here</dd>
<dd>if *piKey &lt; *pArrayMem-&gt;structmem return -1; // any negative value is sufficient/legal</dd>
<dd>if *piKey &gt; *pArrayMem-&gt;structmem return +1; // any positive value is sufficinet/legal</dd>
<dd>return 0;</dd>
</dl>
</dd>
</dl>
<dl>
<dd>
<dl>
<dd>As you can see, there is no "annoying non-uniformity" between the comparison of the simple data types, including char arrays(strings), and complex, user-defined data types defined via struct{}s. There are much more clever ways to search struct{}s, such as using offsetof() to move the array's base pointer over so the compare function can dispense with the need to deal with the -&gt;structmem offset - in which case the original simple datatype compare function would work just fine.</dd>
</dl>
</dd>
</dl>
<p>--<a href="../../../s/o/l/User%7ESolidpoint_f212.html" title="User:Solidpoint">Solidpoint</a> 08:33, 31 March 2007 (UTC)</p>
<p>Nicky, Only a real dipshit programmer would deal with data range issues down at this level in the code. Any seasoned programmer will trap those errors at the data entry or file read level and never, ever would let stuff 3-9 levels down like this deal with those issues. I also have to say that I usually read the assembler that the compiler spits out (or library calls) when I write something this low level and the compiler does produce good assembly language - at least in C. I'm just back from the gym and will have to read your compare function, but in general, it is handled by a function pointer in C and the compare function, which can be arbitrarily complex btw, should test for greater, less than and default to equal as it is the least likely case. Using return statements in the compare function are very efficient because you don't have to exit the function in a uniform way, you can just jump back to the caller with the value supplied.</p>
<dl>
<dd>I'm not too clear what you are on about. The reference <a href="http://googleresearch.blogspot.com/2006/06/extra-extra-read-all-about-it-nearly.html" class="external free" title="http://googleresearch.blogspot.com/2006/06/extra-extra-read-all-about-it-nearly.html" rel="nofollow">http://googleresearch.blogspot.com/2006/06/extra-extra-read-all-about-it-nearly.html</a> by J. Bloch clearly describes the problem. Large collections being searched soon exceeded the span of 16-bit integers, but no problem, everyone relaxed into 32-bit integers which are so big that no-one would ever have a collection of more than a thousand million items to be searched. So, in order to save a trivial action, (L + R)/2 was favoured over (R - L)/2 + L in whatever high-level language was used, and this has its effects all the way down to bit flipping and will cause the high-level system to fail. As for the comparison of keys, again the wording of the high-level language has its effects. In this case, if <i>if-</i>statements are to be used, the binary result of what should be a ternary condition forces a wasteful repetition. As I understand it, C does offer a <i>strcmp</i> function that returns a three-state result, excellent, it may be used in a <i>case</i> statement or, via <i>diff:=strcmp(a,b)</i> the result may be inspected via two <i>if</i>-statements without repetition of the comparison process itself. However, <i>strcmp</i> is for comparison of text strings only. In principle, any ordered datum should be comparable, as is offered by syntax involving &lt; and &gt;, but they only offer binary comparison. Thus there is the annoying situation whereby one syntax can be used for many types (integers of various sizes, floating point of various sizes) but another must be used for string variables. One could imagine a <i>compare(a,b)</i> function that deals with whatever types <i>a</i> and <i>b</i> present and returns a ternary state. This is what I was trying to imply with <i>sign(a - b)</i>, granting a generalisation of subtraction in this context. In the absence of such a multi-type comparison function (hopefully compiled with attention to context), various different formulations might be tried in a high-level language, with potential problems as described.NickyMcLean 23:01, 27 March 2007 (UTC)</dd>
</dl>
<p>I'm not sure who this should be addressed to, but recursive functions work just fine on Intel processors, which have dedicated hardware for building and destroying stack frames. Also, since the whole point of the binary search is that you don't need very many probes the stack frame will never get very deep. If you are building a database engine you might want to optimize with a loop, but the performance hit for recursive functions is not that great. I would encourage you to write a "do nothing" function that calls itself and benchmark it - assuming the compliler isn't so smart as to optimize it into a loop anyway, you will have a better feel for how much performance is suffering. --<a href="../../../s/o/l/User%7ESolidpoint_f212.html" title="User:Solidpoint">Solidpoint</a> 07:18, 10 March 2007 (UTC)</p>
<p><a name="Where_does_the_name_come_from.3F" id="Where_does_the_name_come_from.3F"></a></p>
<h2><span class="editsection">[<a href="../../../b/i/n/Talk%7EBinary_search_algorithm_111d.html" title="Edit section: Where does the name come from?">edit</a>]</span> <span class="mw-headline">Where does the name come from?</span></h2>
<p>Why is this called a "binary" search? What's binary about it? Is it that binary means "can have two values" and here the key can be in one of two places (below or above the midpoint)? Or something about splitting the array in two, and two == binary? Seems pretty weak, but I can't think of a better reason. --<a href="../../../l/k/e/User%7ELkesteloot_031d.html" title="User:Lkesteloot">Lkesteloot</a> 04:02, 28 June 2006 (UTC)</p>
<dl>
<dd>It's because it splits the array in two. That's really it. <a href="../../../d/e/c/User%7EDeco_20f6.html" title="User:Deco">Deco</a> 04:29, 28 June 2006 (UTC)</dd>
</dl>
<p><a name="This_page_needs_some_serious_work" id="This_page_needs_some_serious_work"></a></p>
<h2><span class="editsection">[<a href="../../../b/i/n/Talk%7EBinary_search_algorithm_111d.html" title="Edit section: This page needs some serious work">edit</a>]</span> <span class="mw-headline">This page needs some serious work</span></h2>
<p>Would anybody object if I gave this page a thorough working over? There are so many ideas mixed together here, and many which are missing, or left unexplained, that, on the whole it's just pretty awfull. I've been a professional software engineer and programmer for 25 years or so now and wrote a database engine a few years ago where I used this algorithm extensively. I already know what this thing is, so I don't really need a page on Wiki to tell me about it, but I am willing to have a go at fixing it so long as you are all willing. --<a href="../../../s/o/l/User%7ESolidpoint_f212.html" title="User:Solidpoint">Solidpoint</a> 07:07, 10 March 2007 (UTC)</p>
<p>Why not? (Presumably you mean the article, not the the discussion) - I've tried to present a simple and clear pseudocode, but its non-C nature offended the eyes of some C-lovers and was promptly converted to (incorrect) C, followed by a series of fixes to the mistakes that others then altered by further fixes that created errors (and I bungled one too, alas), and I've given up trying to check that today's version of the pseudocode actually does perform a binary search of elements 1 to N of an array as declared in the text, that it reports "not found" as appropriate, that it succeeds even when N = 0 or 1 as well as more sensible ranges, and it doesn't fail for large N because it doesn't use (L + R)/2. Good luck. NickyMcLean 22:19, 27 March 2007 (UTC)</p>
<p><br />
Nicky, Having thought about the scale problem of (L+R)/2 I think this is a serious problem that should be addressed - a good catch. Before I tackle this I need to get an old machine plugged in, up, and running and don't have time for that right now. I think it would be great to have a good C code here, and one that works. I could also just cut and paste the commented code from Microsoft's C library, at least if I could get permission. A better approach might be to describe a test data set that will quickly test for known failure modes. This kind of low-level functionality really should be written in C or assembly language so we should step up to the plate and get a good C function going. --<a href="../../../s/o/l/User%7ESolidpoint_f212.html" title="User:Solidpoint">Solidpoint</a> 07:54, 31 March 2007 (UTC)</p>

<div class="printfooter">
Retrieved from "<a href="http://en.wikipedia.org../../../b/i/n/Talk%7EBinary_search_algorithm_111d.html">http://en.wikipedia.org../../../b/i/n/Talk%7EBinary_search_algorithm_111d.html</a>"</div>
	    	    <!-- end content -->
	    <div class="visualClear"></div>
	  </div>
	</div>
      </div>
      <div id="column-one">
	<div id="p-cactions" class="portlet">
	  <h5>Views</h5>
	  <ul>
	    <li id="ca-nstab-main"
	       	       ><a href="../../../b/i/n/Binary_search_algorithm.html">Article</a></li><li id="ca-talk"
	       class="selected"	       ><a href="../../../b/i/n/Talk%7EBinary_search_algorithm_111d.html">Discussion</a></li><li id="ca-current"
	       	       ><a href="http://en.wikipedia.org/wiki/Talk:Binary_search_algorithm">Current revision</a></li>	  </ul>
	</div>
	<div class="portlet" id="p-logo">
	  <a style="background-image: url(../../../images/wiki-en.png);"
	    href="../../../index.html"
	    title="Main Page"></a>
	</div>
	<script type="text/javascript"> if (window.isMSIE55) fixalpha(); </script>
		<div class='portlet' id='p-navigation'>
	  <h5>Navigation</h5>
	  <div class='pBody'>
	    <ul>
	    	      <li id="n-Main-page"><a href="../../../index.html">Main page</a></li>
	     	      <li id="n-Contents"><a href="../../../c/o/n/Wikipedia%7EContents_3181.html">Contents</a></li>
	     	      <li id="n-Featured-content"><a href="../../../f/e/a/Wikipedia%7EFeatured_content_24ba.html">Featured content</a></li>
	     	      <li id="n-currentevents"><a href="../../../c/u/r/Portal%7ECurrent_events_bb60.html">Current events</a></li>
	     	    </ul>
	  </div>
	</div>
		<div class='portlet' id='p-interaction'>
	  <h5>interaction</h5>
	  <div class='pBody'>
	    <ul>
	    	      <li id="n-About-Wikipedia"><a href="../../../a/b/o/Wikipedia%7EAbout_8d82.html">About Wikipedia</a></li>
	     	      <li id="n-portal"><a href="../../../c/o/m/Wikipedia%7ECommunity_Portal_6a3c.html">Community portal</a></li>
	     	      <li id="n-contact"><a href="../../../c/o/n/Wikipedia%7EContact_us_afd6.html">Contact us</a></li>
	     	      <li id="n-sitesupport"><a href="http://wikimediafoundation.org/wiki/Fundraising">Make a donation</a></li>
	     	      <li id="n-help"><a href="../../../c/o/n/Help%7EContents_22de.html">Help</a></li>
	     	    </ul>
	  </div>
	</div>
		<div id="p-search" class="portlet">
	  <h5><label for="searchInput">Search</label></h5>
	  <div id="searchBody" class="pBody">
	    <form action="javascript:goToStatic(3)" id="searchform"><div>
	      <input id="searchInput" name="search" type="text"
	        accesskey="f" value="" />
	      <input type='submit' name="go" class="searchButton" id="searchGoButton"
	        value="Go" />
	    </div></form>
	  </div>
	</div>
	      </div><!-- end of the left (by default at least) column -->
      <div class="visualClear"></div>
      <div id="footer">
    <div id="f-poweredbyico"><a href="http://www.mediawiki.org/"><img src="../../../skins/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" /></a></div>	<div id="f-copyrightico"><a href="http://wikimediafoundation.org/"><img src="../../../images/wikimedia-button.png" border="0" alt="Wikimedia Foundation"/></a></div>	<ul id="f-list">
	  	  	  <li id="f-credits">This page was last modified 08:55, 31 March 2007 by Wikipedia user <a href="../../../s/o/l/User%7ESolidpoint_f212.html" title="User:Solidpoint">Solidpoint</a>. Based on work by Wikipedia user(s) NickyMcLean, J4 james, <a href="../../../d/c/o/User%7EDcoetzee_a2a7.html" title="User:Dcoetzee">Dcoetzee</a>, <a href="../../../l/k/e/User%7ELkesteloot_031d.html" title="User:Lkesteloot">Lkesteloot</a>, <a href="../../../e/d/_/User%7EEd_Poor_ed4e.html" title="User:Ed Poor">Ed Poor</a>, <a href="../../../r/o/b/User%7ERobocoder_9b81.html" title="User:Robocoder">Robocoder</a>, <a href="../../../i/e/o/User%7EIeopo_4c8f.html" title="User:Ieopo">Ieopo</a>, <a href="../../../t/e/x/User%7ETexture_fd4f.html" title="User:Texture">Texture</a>, <a href="../../../h/a/n/User%7EHannes_Hirzel_2ceb.html" title="User:Hannes Hirzel">Hannes Hirzel</a> and <a href="../../../d/z/e/User%7EDze27_8d23.html" title="User:Dze27">Dze27</a> and Anonymous user(s) of Wikipedia.</li>	  <li id="f-copyright">All text is available under the terms of the <a class='internal' href="../../../t/e/x/Wikipedia%7EText_of_the_GNU_Free_Documentation_License_702a.html" title="Wikipedia:Text of the GNU Free Documentation License">GNU Free Documentation License</a>. (See <b><a class='internal' href="../../../c/o/p/Wikipedia%7ECopyrights_92c4.html" title="Wikipedia:Copyrights">Copyrights</a></b> for details.) <br /> Wikipedia&reg; is a registered trademark of the <a href="http://www.wikimediafoundation.org">Wikimedia Foundation, Inc</a>., a US-registered <a class='internal' href="../../../5/0/1/501%28c%29.html#501.28c.29.283.29" title="501(c)(3)">501(c)(3)</a> <a href="http://wikimediafoundation.org/wiki/Deductibility_of_donations">tax-deductible</a> <a class='internal' href="../../../n/o/n/Non-profit_organization.html" title="Non-profit organization">nonprofit</a> <a href="../../../c/h/a/Charitable_organization.html" title="Charitable organization">charity</a>.<br /></li>	  <li id="f-about"><a href="../../../a/b/o/Wikipedia%7EAbout_8d82.html" title="Wikipedia:About">About Wikipedia</a></li>	  <li id="f-disclaimer"><a href="../../../g/e/n/Wikipedia%7EGeneral_disclaimer_3e44.html" title="Wikipedia:General disclaimer">Disclaimers</a></li>	  	</ul>
      </div>
    </div>
  </body>
</html>
