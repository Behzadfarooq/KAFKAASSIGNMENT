<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    		<meta name="keywords" content="Wikipedia talk:Algorithms on Wikipedia,Brainfuck programming language,Buchberger's algorithm,C (programming language),Complexity classes P and NP,Counting sort,Courier New,GNU Hurd,Greatest common divisor,Grovers algorithm,Haskell programming language" />
		<link rel="shortcut icon" href="/favicon.ico" />
		<link rel="search" type="application/opensearchdescription+xml" href="/w/opensearch_desc.php" title="Wikipedia (English)" />
		<link rel="copyright" href="../../../COPYING.html" />
    <title>Wikipedia talk:Algorithms on Wikipedia - Wikipedia, the free encyclopedia</title>
    <style type="text/css">/*<![CDATA[*/ @import "../../../skins/htmldump/main.css"; /*]]>*/</style>
    <link rel="stylesheet" type="text/css" media="print" href="../../../skins/common/commonPrint.css" />
    <!--[if lt IE 5.5000]><style type="text/css">@import "../../../skins/monobook/IE50Fixes.css";</style><![endif]-->
    <!--[if IE 5.5000]><style type="text/css">@import "../../../skins/monobook/IE55Fixes.css";</style><![endif]-->
    <!--[if IE 6]><style type="text/css">@import "../../../skins/monobook/IE60Fixes.css";</style><![endif]-->
    <!--[if IE]><script type="text/javascript" src="../../../skins/common/IEFixes.js"></script>
    <meta http-equiv="imagetoolbar" content="no" /><![endif]-->
    <script type="text/javascript" src="../../../skins/common/wikibits.js"></script>
    <script type="text/javascript" src="../../../skins/htmldump/md5.js"></script>
    <script type="text/javascript" src="../../../skins/htmldump/utf8.js"></script>
    <script type="text/javascript" src="../../../skins/htmldump/lookup.js"></script>
    <script type="text/javascript" src="../../../raw/gen.js"></script>        <style type="text/css">/*<![CDATA[*/
@import "../../../raw/MediaWiki%7ECommon.css";
@import "../../../raw/MediaWiki%7EMonobook.css";
@import "../../../raw/gen.css";
/*]]>*/</style>          </head>
  <body
    class="ns-5">
    <div id="globalWrapper">
      <div id="column-content">
	<div id="content">
	  <a name="top" id="contentTop"></a>
	        <h1 class="firstHeading">Wikipedia talk:Algorithms on Wikipedia</h1>
	  <div id="bodyContent">
	    <h3 id="siteSub">From Wikipedia, the free encyclopedia</h3>
	    <div id="contentSub"></div>
	    	    <div class="usermessage">You have <a href="../../../1/2/7/User_talk%7E127.0.0.1.html" title="User talk:127.0.0.1">new messages</a> (<a href="../../../1/2/7/User_talk%7E127.0.0.1.html" title="User talk:127.0.0.1">last change</a>).</div>	    <!-- start content -->
	    <table id="toc" class="toc" summary="Contents">
<tr>
<td>
<div id="toctitle">
<h2>Contents</h2>
</div>
<ul>
<li class="toclevel-1"><a href="#C.2B.2B"><span class="tocnumber">1</span> <span class="toctext">C++</span></a></li>
<li class="toclevel-1"><a href="#Recursion_vs._Iteration"><span class="tocnumber">2</span> <span class="toctext">Recursion vs. Iteration</span></a></li>
<li class="toclevel-1"><a href="#Role_of_this_page"><span class="tocnumber">3</span> <span class="toctext">Role of this page</span></a></li>
<li class="toclevel-1"><a href="#Pseudocode_vs._real_code"><span class="tocnumber">4</span> <span class="toctext">Pseudocode vs. real code</span></a></li>
<li class="toclevel-1"><a href="#Choice_of_language_criteria"><span class="tocnumber">5</span> <span class="toctext">Choice of language criteria</span></a></li>
<li class="toclevel-1"><a href="#Standardized_pseudocode"><span class="tocnumber">6</span> <span class="toctext">Standardized pseudocode</span></a></li>
<li class="toclevel-1"><a href="#Samples_of_code_for_popularity"><span class="tocnumber">7</span> <span class="toctext">Samples of code for popularity</span></a></li>
<li class="toclevel-1"><a href="#Haskell.3F"><span class="tocnumber">8</span> <span class="toctext">Haskell?</span></a></li>
<li class="toclevel-1"><a href="#Proposal:_construct_our_own_.22executable_pseudocode.22"><span class="tocnumber">9</span> <span class="toctext">Proposal: construct our own "executable pseudocode"</span></a></li>
<li class="toclevel-1"><a href="#LiteratePrograms"><span class="tocnumber">10</span> <span class="toctext">LiteratePrograms</span></a></li>
<li class="toclevel-1"><a href="#Major_Changes"><span class="tocnumber">11</span> <span class="toctext">Major Changes</span></a></li>
<li class="toclevel-1"><a href="#The_programming_language_in_algorithm_articles"><span class="tocnumber">12</span> <span class="toctext">The programming language in algorithm articles</span></a></li>
<li class="toclevel-1"><a href="#Pseudocode_syntax"><span class="tocnumber">13</span> <span class="toctext">Pseudocode syntax</span></a></li>
</ul>
</td>
</tr>
</table>
<script type="text/javascript">
//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>
</script>
<p><a name="C.2B.2B" id="C.2B.2B"></a></p>
<h2><span class="editsection">[<a href="../../../a/l/g/Wikipedia_talk%7EAlgorithms_on_Wikipedia_2af5.html" title="Edit section: C++">edit</a>]</span> <span class="mw-headline">C++</span></h2>
<p>This is a simple issue. Use C++ without any object oriented constructs and without pointers except for binary trees and other dynamically allocated data structures. References should be used whenever possible. Also, no macros.</p>
<p>Secondly, clarity/readability should be emphasized over speed.</p>
<p>Advantages:</p>
<ul>
<li>
<ul>
<li>basic syntax of C++ is essentially the same/easily understandable by programmers in other languages</li>
<li>C is widely known</li>
<li>Avoids Unix specific languages such as Ruby, Python, Perl, etc. (NB: Technically, these are portable but almost all users of those languages use linux/unix).</li>
</ul>
</li>
</ul>
<dl>
<dd>Why C++ and not C? Also although a lot of samples are in C, once you start having to deal with pointers it's probably getting too bogged down in the C-ness of it and you need a more "pseudo"-type language such as Python. —<a href="../../../e/a/t/User%7EEatMyShortz_1fd5.html" title="User:EatMyShortz">EatMyShortz</a> 13:55, 14 February 2006 (UTC)</dd>
</dl>
<dl>
<dd>There's a very good reason not to use C/C++ exclusively. Their syntax has a lot of problems, and C++ in particular is extremely verbose, even for relatively simple things. A lot of the built-in operators are counterintuitive to people who just know high-school math, such as assignment/equality, not-equals, bitwise versus logical and/or, and so on. They use different bitwise operators from computer engineers. Damian Conway has written papers on how confusing C/C++'s declaration syntax is. Additionally, C is limited to fixed-size integers, which makes many algorithms in number theory and other areas much more complicated. C++ at least has string operators, That said, I do support <i>procedural</i> code samples for most things, and I have often used C samples where they are simple. <a href="../../../d/e/c/User%7EDeco_20f6.html" title="User:Deco">Deco</a> 20:07, 14 February 2006 (UTC)</dd>
</dl>
<dl>
<dd>
<dl>
<dd>I don't think using any concrete programming language is a good idea, as the clearest algorithms are written with appropriate section in words, e.g. <code>union of <i>X<sub>i</sub></i> for i ∈ { 1 ... n }</code> is infinitely clearer than <code>(apply union xs)</code> in Lisp/Scheme, <code>foldl union [] xs</code> in Haskell, and the corresponding C++ iterator loop. --<a href="../../../m/g/r/User%7EMgreenbe_c499.html" title="User:Mgreenbe">Mgreenbe</a> 20:35, 14 February 2006 (UTC)</dd>
</dl>
</dd>
</dl>
<dl>
<dd>
<dl>
<dd>I have to agree with <a href="../../../m/g/r/User%7EMgreenbe_c499.html" title="User:Mgreenbe">Mgreenbe</a> that the requirement of executable code in a concrete programming language is only going to obfuscate things. High level pseudocode allows you to condense something that would require considerable complexity in a concrete language into a simple and accessible description in pseudocode. For instance I think it would be hard to write an executable version of <a href="../../../b/u/c/Buchberger%27s_algorithm.html" title="Buchberger's algorithm">Buchberger's algorithm</a> in C or C++ or Scheme or Python that is going to be as clear as the psuedocode presented - far too much code would be spent dealing with the complications of implementation rather than in explicating the important steps of the alorithm itself. <a href="../../../l/e/l/User%7ELeland_McInnes_a728.html" title="User:Leland McInnes">Leland McInnes</a> 22:03, 14 February 2006 (UTC)</dd>
</dl>
</dd>
</dl>
<dl>
<dd>
<dl>
<dd>I agree that it's not good to use a certain programming language indefinitely. In the case of Buchburger's algorithm, that's explained as it stands in a mixture of pure maths and english - a very pseudo pseudocode. Which is good - since it's broken down into these neat steps and it's a very mathematical procedure, it's good to have it expressed like that. I think problems like this though should be explained in "pseudo pseudocode" and then also more detailed in "pseudocode" - see <a href="../../../l/o/n/Longest-common_subsequence_problem.html" title="Longest-common subsequence problem">Longest-common subsequence problem</a>, where it is explained twice - thrice in fact. So I think we should only use computer code for either simpler things, or more-computational-less-mathematical things. Python would be my language of choice - even if you've never used it it is very easy to understand, some of my lecturers use it for pseudocode even though they haven't taught us the language. C should be used on things like '<a href="../../../p/o/i/Pointer.html" title="Pointer">Pointer</a>' where it's necessary to explain it. —<a href="../../../e/a/t/User%7EEatMyShortz_1fd5.html" title="User:EatMyShortz">EatMyShortz</a> 02:14, 15 February 2006 (UTC)</dd>
</dl>
</dd>
</dl>
<dl>
<dd>
<dl>
<dd>
<dl>
<dd>How about <a href="../../../t/o/p/Topological_sort.html" title="Topological sort">Topological sort</a> then? That's largely computational and is fairly simple. The algorithm, as presented in pseudocode, is quite clear. Converting that into executable code is going to involve declarations of some sort of data structure to hold the graph, and then manipulations specific to that structure cluttering up the internals of the algorithm itself. The result will still be readable, but it will be more complex, less clear, and do a much poorer job of actually expressing the important points with regard to how the algorithm works.</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<dl>
<dd>
<dl>
<dd>
<dl>
<dd>Pseudocode is also more neutral, thus less inclined to induce language wars and redundancy via multiple different implementations in multiple different langauges. Pseudocode is also more flexible - you aren't bound to a the constructs offered by a particular implementation: for example pseudocode could support pointers, or pattern matched functions, or dependent types. As long as you can find a clear generic way of expressing it, pseudocode can be bent to any task required of it. I don't believe that's particularly true of any concrete languages - certainly not without extra hoop jumping (such as metaprogramming in Lisp) to set it up. I would ask, instead, what the benefit of expressing algorithms in a concrete language is. Anything presented as (pseudo-)code on Wikipedia ought to be referenced and verifiable by inspection, so correctness can't be the issue. If you want to provide people with a working example they can play with - you're making the assumption they have a compiler or interpreter for the language you've chosen. Instead working examples would much better be provided on a linked page or on Wikisource as a respository of implementations in as many different languages as people care to submit - why limit yourself to one implementation language, and why clutter the main page with multiple implementations in different languages?</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<dl>
<dd>
<dl>
<dd>
<dl>
<dd>It seems to me that pseudocode is the most neutral, the most expressive, the most flexible, the most consistent, and the simplest solution. I see few real benefits to using a concrete language that can't be obtained by simply linking to a page of concrete implementations. In turn there is much to be lost in straightjacketing yourself into concrete implementations, particularly if you want to have consistency. Surely pseudocode, standardised with some basic guidelines outlining suitable style, is the most natural answer? <a href="../../../l/e/l/User%7ELeland_McInnes_a728.html" title="User:Leland McInnes">Leland McInnes</a> 02:40, 15 February 2006 (UTC)</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<dl>
<dd>
<dl>
<dd>
<dl>
<dd>
<dl>
<dd>Well expressed - I agree. I think the only problem with pseudocode is that it *isn't* standardised so as somebody said, it isn't immediately clear what you mean by "=" for example, and some people start using &lt;- arrowey things for assignation, and it all becomes inconsistent. I'd like to see some consistent pseudocode rules set up, with the intention of having <i>writers</i> need to know the rules and follow them, but <i>readers</i> can understand them just by looking. However this has already been proposed and failed (<a href="../../../d/c/o/User%7EDcoetzee_Wikicode_bb45.html" title="User:Dcoetzee/Wikicode">Wikicode</a>), probably because nobody took the interest to learn how to write it. —<a href="../../../e/a/t/User%7EEatMyShortz_1fd5.html" title="User:EatMyShortz">EatMyShortz</a> 13:52, 19 February 2006 (UTC)</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<dl>
<dd>
<dl>
<dd>
<dl>
<dd>
<dl>
<dd>
<dl>
<dd>Why not have a look at the draft <a href="../../../w/i/k/Wikipedia%7EWikiProject_Computer_science_Manual_of_style_%28computer_science%29_a8c5.html" title="Wikipedia:WikiProject Computer science/Manual of style (computer science)">Wikipedia:WikiProject Computer science/Manual of style (computer science)</a>? I think most of the feeling is against strict pseudocode structure, but syntax we can agree on. --<a href="../../../m/g/r/User%7EMgreenbe_c499.html" title="User:Mgreenbe">Mgreenbe</a> 14:37, 19 February 2006 (UTC)</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p><a name="Recursion_vs._Iteration" id="Recursion_vs._Iteration"></a></p>
<h2><span class="editsection">[<a href="../../../a/l/g/Wikipedia_talk%7EAlgorithms_on_Wikipedia_2af5.html" title="Edit section: Recursion vs. Iteration">edit</a>]</span> <span class="mw-headline">Recursion vs. Iteration</span></h2>
<p>I can appreciate the emphasis on iteration versus recursion, as recursion is not taught to some people. I don't agree that iteration is always preferable. A recursive algorithm that searches a binary tree is simpler to understand, requires less book-keeping in variables, and is in general, preferable when explaining to a neophyte. I think there are an entire class of problems that are similar. --BenBaker</p>
<p>I'm aware that recursion vs. iteration is one of more controversial of hints listed. There is certainly class of problems are much easier to solve using recursion than iteration. That is a hint for problems that can be solved equally easily with both methods (like fibonacci).</p>
<p>There is also a problem that various people find either of methods "simpler to understand". There's some point in providing both implementations, so both groups can find easy-to-understand algorithm.</p>
<p>Probably some weaker wording should be used. --<a href="../../../t/a/w/User%7ETaw_8bc0.html" title="User:Taw">Taw</a></p>
<hr />
<p>Iterative where immediately apparent would be nice. On the other hand, if its a problem that lends itself to recursion, no reason not to. programming is complicated, there's no two ways about it.</p>
<p>BTW, Even with iterative constructs available in LISP, I tend to go recursive just because the language lends itself to it, but in C I go iterative if I can help it. Something to think about... --alan d</p>
<p><a name="Role_of_this_page" id="Role_of_this_page"></a></p>
<h2><span class="editsection">[<a href="../../../a/l/g/Wikipedia_talk%7EAlgorithms_on_Wikipedia_2af5.html" title="Edit section: Role of this page">edit</a>]</span> <span class="mw-headline">Role of this page</span></h2>
<p>I think this page should be renamed "List of Algorithms", should have a one-line explanation of every algorithm, and should be listed on <a href="../../../r/e/f/Reference_tables.html" title="Reference tables">Reference tables</a>. I don't think it makes much sense to try to dictate in which way people are to write sample implementations. Personally, I'd prefer pseudo code. Also, why is it directed at <b>Unix</b> programmers? What about <a href="../../../g/n/u/GNU_Hurd_2121.html" title="GNU Hurd">Hurd</a> hackers? --AxelBoldt</p>
<hr />
<ul>
<li>Page name is almost irrelevant.</li>
<li>One-line ok</li>
<li>Reference Tables done</li>
<li>It's not discating, it's setting standards</li>
<li>It makes LOT of sense. Bad sample implementation is almost completely useless.</li>
<li>Pseudo code is <b>really</b> bad idea. It is in no aspect better than real languages like Ruby or Python. It's impossible to test, so may contain errors and one has to assume many things like array indexing about it. Pseudocode should be discouraged.</li>
<li>It should be directed at Unix programmers, because majority of people interesed in this topic knows Unix or technologies that come from it, like C. No Unix-specific quirks in code of course.</li>
<li>Objectively speaking, <a href="../../../g/n/u/GNU_Hurd_2121.html" title="GNU Hurd">Hurd</a> is kind of Unix or at least mostly Unix-compatible.</li>
<li><a href="../../../g/n/u/GNU_Hurd_2121.html" title="GNU Hurd">Hurd</a> hackers are very small group of people and I'm sure that all of them know some other Unices.</li>
</ul>
<p>--<a href="../../../t/a/w/User%7ETaw_8bc0.html" title="User:Taw">Taw</a></p>
<ul>
<li>Page names involving "Wikipedia" are generally taken to be meta articles about Wikipedia, not genuine Wikipedia articles. If this is intended to be a <i>policy</i> article about Wikipedia coding standards, then there should be a separate list of algorithms.</li>
<li>While it is true that pseudo code cannot be tested, it is intended for human understanding and may therefore contain less errors. Programming languages often contain obscure constructs (= vs == for instance, or overloaded division /) which make understanding harder. Just because you can test a program doesn't mean that it is less likely to have errors.</li>
<li>The reference to Hurd was a joke. I was alluding to the fact that there are many programmers which don't use Unix.</li>
</ul>
<p>The article should be directed at programmers, period. --AxelBoldt</p>
<p><a name="Pseudocode_vs._real_code" id="Pseudocode_vs._real_code"></a></p>
<h2><span class="editsection">[<a href="../../../a/l/g/Wikipedia_talk%7EAlgorithms_on_Wikipedia_2af5.html" title="Edit section: Pseudocode vs. real code">edit</a>]</span> <span class="mw-headline">Pseudocode vs. real code</span></h2>
<p>So the only unresolved issue is pseudocode, right&#160;?</p>
<p>Arguments for pseudocode and against simple real languages:</p>
<ul>
<li>Rarely used languages like Ruby may confuse readers</li>
<li>Pseudo code forces the programmer to think through the algorithm before implementing it; the danger with real code is that they just cut and paste</li>
<li>Pseudo code can focus in on the heart of the algorithm, glossing over trivial parts (initializing of arrays, type casts)</li>
<li>Pseudo code is the most concise description of an algorithm designed for human consumption, programming languages are designed for consumption by computers.</li>
<li>Pseudo code can use generally established conventions of mathematical notation (<i>x</i><sup><i>n</i></sup>, √<i>x</i>, <i>x</i> mod <i>n</i>), while avoiding idiosyncracies of programming languages.</li>
<li>Any algorithm that can be expressed at all can be expressed in pseudo code; some algorithms can not be expressed in some programming languages.</li>
<li><i>...</i></li>
</ul>
<p>Arguments for simple real languages and against pseudocode:</p>
<ul>
<li>Pseudocode can't be easily tested, so may contain subtle errors like off-by-one</li>
<li>Pseudocode needs explanations about things like == vs. =, type of division, array indexing etc. before each example</li>
<li>Pseudocode isn't standarized, so it may confuse reader</li>
<li>Reader can't play with sample implementation, and playing can help to understand in case of some algorithms</li>
<li>Pseudocode needs some redundant information, for example it must have array size specified as separate variable, while in most languages constructs like <tt>array.size</tt> can be used to get it.</li>
<li>Pseudocode can't be easily used for many algorithms, for example those involving pointers</li>
<li><i>...</i></li>
</ul>
<dl>
<dd>
<dl>
<dd>I think the argument that "Pseudocode can't be easily tested" is a spurious one. Unless we're engaged in "original research", the pseudocode in question should be coming from some external (referenced) source, so there shouldn't be any <i>need</i> to test it (although there might be a need to proof-read it against the reference). With regard to the argument about sample implementations
<ol>
<li>constructing their <i>own</i> sample implementation based on the pseudocode will probably help the reader gain an even better understanding of the algorithm</li>
<li>unless we're planning on providing sample implementations in every conceivable language, there's a chance that $RANDOMREADER won't be able to make use of the sample implementation anyway</li>
<li>there's nothing that says that there shouldn't be a few sample implementations <i>in addition to</i> a good language-independent pseudocode description of the algorithm</li>
</ol>
</dd>
<dd>--<a href="../../../a/l/l/User%7EAllan_McInnes_23d1.html" title="User:Allan McInnes">Allan McInnes</a> 00:44, 29 January 2006 (UTC)</dd>
</dl>
</dd>
</dl>
<hr />
<p>I'm moving Ruby into the list of less-recommended languages. Smalltalk and Eiffel both have many more users than Ruby does, so if you're going to recommend against them (which I think is reasonable), then you have to take out Ruby as well. The only ones I think have a significant enough user base that any programmer should at least be familiar with them are C/C++, Java, BASIC, Pascal, Perl, and Python. BASIC and Pascal are bad because there are too many incompatible variants.</p>
<p>-- <a href="../../../l/e/e/User%7ELee_Daniel_Crocker_4538.html" title="User:Lee Daniel Crocker">LDC</a></p>
<p>C programs can be a mess because to write them portably, taking into account char-size, endianness etc., can make them unreadable. While I like Perl, I think it is unreadable unless you have really used it quite a bit. Ideally, I would like the sample implementations to be relevant to beginning computer science students as well as to working programmers. --AxelBoldt</p>
<p><a name="Choice_of_language_criteria" id="Choice_of_language_criteria"></a></p>
<h2><span class="editsection">[<a href="../../../a/l/g/Wikipedia_talk%7EAlgorithms_on_Wikipedia_2af5.html" title="Edit section: Choice of language criteria">edit</a>]</span> <span class="mw-headline">Choice of language criteria</span></h2>
<p>There are two things that need to be considered in choosing languages - its readability and its popularity. That's why languages like Python and Ruby, which were designed (successfully) with readability in mind are more apropriate, while Perl and C are less apropriate, than they would be if only popularity mattered. I put Eiffel and Smalltalk on discouraged list not only because of their little popularity but also because of their non-standard syntax, and it case of Smalltalk, philosophy.</p>
<p>About popularity:</p>
<ul>
<li>From <a href="http://www.eros-os.org/pipermail/e-lang/2001-October/005793.html" class="external free" title="http://www.eros-os.org/pipermail/e-lang/2001-October/005793.html" rel="nofollow">http://www.eros-os.org/pipermail/e-lang/2001-October/005793.html</a> (freshmeat projects count, only relevant entries quoted):
<ul>
<li>Python: 403</li>
<li>Ruby: 31</li>
<li>Eiffel: 16</li>
<li>Delphi: 15</li>
<li>Pascal: 15</li>
<li>Smalltalk: 3</li>
<li>Visual Basic: 6</li>
<li>Object Pascal: 4</li>
<li>Basic: 1</li>
<li>so if Unix hackers are considered, BASIC, Pascal, Smalltalk and Eiffel are less popular than you stated while Ruby is more. (in other groups, popularity ranking will be different)</li>
</ul>
</li>
<li>BASIC and Pascal aren't bad only because there are too many variants. There are many bigger problems with these languages. (details are easy to find online)</li>
<li>Nowadays most new programmers aren't familiar with Pascal and BASIC. They might have seen some code, but haven't used it to do anything serious. Most schools don't use these languages for teaching and they are virtually unused in UNIX world.</li>
<li>Ruby's popularity is comparable to Python's in Japan (there was article on /. about it, but i don't have hard data handy) --<a href="../../../t/a/w/User%7ETaw_8bc0.html" title="User:Taw">Taw</a></li>
<li>Algol was specifically designed to be used for print media in a pseudocodish kind of way. Why not continue the tradition?</li>
</ul>
<p><a name="Standardized_pseudocode" id="Standardized_pseudocode"></a></p>
<h2><span class="editsection">[<a href="../../../a/l/g/Wikipedia_talk%7EAlgorithms_on_Wikipedia_2af5.html" title="Edit section: Standardized pseudocode">edit</a>]</span> <span class="mw-headline">Standardized pseudocode</span></h2>
<p>As a beginning computer science student, I request that all algorithms be written in a Wikipedia-standardized pseudocode. I'm not particularly familiar with any language, and IMO, the most generalized presentation would be of greatest benefit. There's no reason why there can't <i>also</i> be implementations in Python or Java, giving us the best of both worlds. --<a href="../../../s/t/e/User%7EStephen_Gilbert_b934.html" title="User:Stephen Gilbert">Stephen Gilbert</a></p>
<hr />
<p>What's the point in "standard" pseudocode as compared to using simple real world language&#160;? --<a href="../../../t/a/w/User%7ETaw_8bc0.html" title="User:Taw">Taw</a></p>
<dl>
<dd>I find that pseudocode helps me understand the general algorithm, as opposed to a specific implementation of it. Why can't both pseudocode and a simple real world language be used? --<a href="../../../s/t/e/User%7EStephen_Gilbert_b934.html" title="User:Stephen Gilbert">Stephen Gilbert</a></dd>
</dl>
<p><a name="Samples_of_code_for_popularity" id="Samples_of_code_for_popularity"></a></p>
<h2><span class="editsection">[<a href="../../../a/l/g/Wikipedia_talk%7EAlgorithms_on_Wikipedia_2af5.html" title="Edit section: Samples of code for popularity">edit</a>]</span> <span class="mw-headline">Samples of code for popularity</span></h2>
<p>Freshmeat is hardly an unbiased sample, and the numbers quoted are too small to mean much anyway. Google returns twice about as many hits for "Smalltalk language" and "Eiffel language" as it does for "Ruby language". Check out any bookstore: you're likely to find 5-10 books on Eiffel and Smalltalk; I think only one Ruby book exists. Smalltalk is big in academia as a teaching language (like Pascal used to be, and Java is now), so a lot of people are familiar with it even if it doesn't get used for real projects much. I have no idea what you mean by its "philosophy" or why that matters. BASIC isn't used in academia and it's not used much in Unix, but it's still the #1 most popular programming language by many measures--let's not kid ourselves that the world is Unix--the world in Windows, and us Unix hackers are growing minority, but still a minority.</p>
<p>The Ruby code does have the advantage that it's pretty readable as pseudocode for simple things. All in all, I think if I were to add code samples here, I'd use Java (which you omitted from the table above--its count is 740, above all those you mentioned and below C/C++, Perl, and PHP), since it is quite common, well-defined and standardized, and quite readable. -LDC</p>
<hr />
<ul>
<li>By user count, world may be Windows, but by programmer count it's not.</li>
<li>I wouldn't call Java very "readable".</li>
<li>Google count for 'basic language' and 'basic programming language' contains mostly false positives on main page - basic is popular english word after all</li>
</ul>
<p>Your first point may be true; it would be hard to measure. Perhaps the "bookstore" metric would be useful there as well (that is, count the sales of related books). I personally don't find Java any less readable than Python or Ruby; they all use the same operators, keywords are sensible, etc. At any rate, that's a matter of personal taste. Yes, searching for "BASIC language" on Google would be silly, which is why I didn't do or suggest it. Even the ones I did do are only the roughest possible estimate, just like your "Freshmeat" metric. Another metric that might be useful is to look at newspaper job advertisements. Java, C, and BASIC (usually MS VB) programmers are in greatest demand, followed by Perl, ASP (a BASIC derivative), and miscellaneous others.</p>
<hr />
<p>I'd support using real programming code (my favourites would be C/C++ or Java, but take your pick), not psuedocode. The problem with psuedocode is that there are no standards, and sometimes it is difficult to interpret. At least with real programming code, there is always only one (in theory at least) interpretation for the code. -- <a href="../../../s/j/k/SJK_88ad.html" title="SJK">SJK</a></p>
<hr />
<p>Why don't we just let everybody use their favorite programming language? That way, not only will we get the biggest possible catalog of sample implementation, but we will also get a nice collection of sample code snippets that we can link to from the respective programming language pages. Whenever you come across an ugly sample implementation in language you don't understand, like <a href="../../../s/c/h/Scheme_programming_language.html" title="Scheme programming language">Scheme</a>, just add your own implementation written in <a href="../../../b/r/a/Brainfuck_programming_language.html" title="Brainfuck programming language">Brainfuck</a>. Can't hurt, can it? --AxelBoldt</p>
<hr />
<p>Nobody's saying that one can't add another sample implementation, if there is some reason of doing it. Hints are made so people have easier time if they're unsure what's the good way. --<a href="../../../t/a/w/User%7ETaw_8bc0.html" title="User:Taw">Taw</a></p>
<hr />
<p>I'd prefer real code to pseudocode in general, but sometimes pseudocode is far more readable. For example, I just added an algorithm to <a href="../../../c/o/m/Complexity_classes_P_and_NP_8d78.html" title="Complexity classes P and NP">Complexity_classes_P_and_NP</a>. It's 8 lines of pseudocode, and fairly readable (I think). In any real language, this would be far less readable, since you'd have to build an interpretor, and deal with all sorts of data structures that aren't really important to the central idea. --<a href="../../../l/c/_/User%7ELC_0e98.html" title="User:LC">LC</a></p>
<hr />
<p>But that's because it's hardly an "algorithm", it's rather abstract mathematical construct --<a href="../../../t/a/w/User%7ETaw_8bc0.html" title="User:Taw">Taw</a></p>
<p>That's what algorithms are! Actual code implements an algorithm, which is the abstract mathematical construct of a sequence of steps to produce a result. Taw uses pseudocode here to give a very high-level presentation of an idea. In a real language, you'd have to just put in a procedure call like "RunProgram(x)", and comment that this is left as an exercise for the reader.&#160;:-)</p>
<hr />
<p>The list of algorithms seems to be rather slewed towards algorithms used in computer programming. Do algorithms like <a href="../../../g/r/e/Greatest_common_divisor.html" title="Greatest common divisor">Euclid's algorithm</a> (a numerical algorithm) and <a href="../../../g/r/o/Grovers_algorithm.html" title="Grovers algorithm">Grover's algorithm</a> (a <a href="../../../q/u/a/Quantum_computer.html" title="Quantum computer">quantum algorithm</a>) belong? Or are the lists meant to be geared towards computer programming? -- <a href="../../../c/y/d/User%7ECYD_b425.html" title="User:CYD">CYD</a></p>
<p><a name="Haskell.3F" id="Haskell.3F"></a></p>
<h2><span class="editsection">[<a href="../../../a/l/g/Wikipedia_talk%7EAlgorithms_on_Wikipedia_2af5.html" title="Edit section: Haskell?">edit</a>]</span> <span class="mw-headline">Haskell?</span></h2>
<p>A couple of points:</p>
<ul>
<li>OOP is about programming in the large. For programming in the small (to provide illustrative examples of algorithms, for instance), OOP is just a bunch of unnecessary cruft. Hence, Java and C++ don't add very much over C <i>for the purpose of illustrating fundamental algorithms,</i> and the cruft gets in the way of understanding.</li>
<li>Some of the HLL's (Perl, for instance), aren't exactly ideal for describing implementations of data structures (trees, hash tables etc).</li>
<li>As far as the untestability of pseudocode, most algorithms we present should be verifiable by inspection.</li>
<li>Perl looks ugly and encourages, er, idiosyncratic coding. It's great for getting jobs done. It's bad for presenting examples in, IMHO.</li>
<li>Of course, I think we should present most of our algorithms in something like <a href="../../../h/a/s/Haskell_programming_language.html" title="Haskell programming language">Haskell</a>, but I can't see us winning that argument&#160;:) --<a href="../../../r/o/b/User%7ERobert_Merkel_dd17.html" title="User:Robert Merkel">Robert Merkel</a></li>
</ul>
<dl>
<dd>Yeah <a href="../../../r/o/b/User%7ERobert_Merkel_dd17.html" title="User:Robert Merkel">Robert</a> I agree at most. Especially for C as I don't understand all the HLL's, PERL's, IMHO's, Haskell 98's, Haskell++, O'Haskell's and Mondrian's stuff you've written. C++ and Java are very active nowadays and perhaps according to C++, through C# and some other futher classification efforts C will see its own rebirth. I am also very much interested in RPN programming and in <a href="../../../m/a/p/Maple_computer_algebra_system.html" title="Maple computer algebra system">Maple</a> V R4.00a codeing for the <a href="../../../n/u/m/Number_theory.html" title="Number theory">number theory</a> applications. --<a href="../../../x/j/a/User%7EXJamRastafire_2aa5.html" title="User:XJamRastafire">XJamC</a> 4 Wednesday (Thor's day) [2002.02.28) (0)</dd>
</dl>
<p>I suggest as a compromise the <a href="../../../p/y/t/Python_programming_language.html" title="Python programming language">Python programming language</a> one of the most readable progamming languages, often described as "executable pseudocode". -- Anon.</p>
<hr />
<p>I would be very much in favour of real pseudo-code. This has benefits that</p>
<ul>
<li>No programmer is "angry" because the implementation is in a - in his eyes - stupid, silly, inferior programming language (it's NPOV). Moreover, they will not feel compelled to add other versions of the same algorithm</li>
<li>No details of implementation have to be presented, and use of mathematical signs (also variables with subscripts) or plain text make the code very readable</li>
<li>Pseudocode makes it possible to focus on what's important about the algorithm.</li>
<li>An encyclopedia is about things, not the things themselves. Therefore, having executable code is not very useful (it's not in all languages anyway). If somebody is interested in implementing one of the algorithms, pseudocode should give him more than enough information to implement things in his favourite language, especially if the article also contains some pointers on implementation details (f.e., an algorithm on graphs can point to an article Graph representation in programming, or something like that.</li>
</ul>
<p>I could probably go on here, but I think my point is clear. A problem of pseudo-code is of course that there's no standard, but it should not be a problem to create a Wikipedia pseudo code language, and linking to explanation when used. <a href="../../../j/h/e/User%7EJheijmans_2d7f.html" title="User:Jheijmans">Jeronimo</a></p>
<p><br /></p>
<dl>
<dd>If you fully define a pseudocode then it becomes a code. Next thing someone will write a complier for it, then people will start with the language pissing matches etc....&#160;;-)</dd>
</dl>
<dl>
<dd>
<dl>
<dd>Hehe, you might be right. But te definition should simply define some syntax (assignment, if-then-else, while-do, etc). The rest of the notation should be relatively free. That's why it's <i>pseudo-code</i>. <a href="../../../j/h/e/User%7EJheijmans_2d7f.html" title="User:Jheijmans">Jeronimo</a></dd>
</dl>
</dd>
</dl>
<p><a name="Proposal:_construct_our_own_.22executable_pseudocode.22" id="Proposal:_construct_our_own_.22executable_pseudocode.22"></a></p>
<h2><span class="editsection">[<a href="../../../a/l/g/Wikipedia_talk%7EAlgorithms_on_Wikipedia_2af5.html" title="Edit section: Proposal: construct our own &quot;executable pseudocode&quot;">edit</a>]</span> <span class="mw-headline">Proposal: construct our own "executable pseudocode"</span></h2>
<p>I've been thinking about the real-language versus pseudocode debate, and I think an interesting compromise would be to construct an "executable pseudocode" language with a real interpreter specifically with the aims of readability, simplicity, and brevity in small code samples. To facilitate embedded English statements, we could either allow English statements to "summarize" (hide) sections of code that implement them, or we could have the interpreter pause and make the human interpret the English statement. This would allow us to test code samples without succumbing to the idiosyncrisies and verbosity of real languages, with the additional benefit of ensuring regularity of syntax for common constructs like loops. Real languages could still be used where one is particularly suitable or simple, or in a supplementary fashion.</p>
<p>This is all a little abstract, so here's a contrived example. Let's say you type this very C-like text into a text file:</p>
<pre>
function insert(array a, int length, value) {
    set i to index of last element
    while i &gt;= 0 and a[i] &gt; value {
        a[i + 1] := a[i];
        i--;
    }
    a[i + 1] := value;
}
</pre>
<p>You run it through a "beautifier" which converts it to this pretty wikitext, expanding or replacing counterintuitive constructs and operators and adding bold/italics:</p>
<pre>
<b>function</b> insert(<i>array</i> a, <i>int</i> length, value) {
    <i>set i to index of last element</i>
    <b>while</b> i ≥ 0 <b>and</b> a[i] &gt; value
        a[i + 1] ← a[i]
        i ← i − 1
    a[i + 1] ← value
}
</pre>
<p>Next you load this up in the interpreter. It gives you an input-eval-print loop in which to enter test invocations. Let's say you type "insert({1,3,5,0},3,2)". It executes the above function, and when you get to "set i to index of last element", the interpreter stops and asks you to carry this action out. You type "i&#160;:= 2" and then continue running. The result "{1,2,3,5}" comes back.</p>
<p>So that's a brief preview - any suggestions or criticism welcome. <a href="../../../d/e/c/User%7EDeco_20f6.html" title="User:Deco">Deco</a> 21:23, 14 February 2006 (UTC)</p>
<dl>
<dd>Who would be entering an algorithm that is unable to either (1) test and experiment with a working implementation or (2) prove correctness (perhaps following a proof in a book)? I feel like anyone who doesn't fall into one of these two categories shouldn't be entering algorithms. So would this be helpful to readers? I wouldn't find much use from it (biased sample). Perhaps it would be more helpful to leverage <a href="../../../c/o/m/WP%7ECOMPSCI_667d.html" title="WP:COMPSCI">WPCS</a> to add real-language implementations of algorithms to Wikisource. --<a href="../../../m/g/r/User%7EMgreenbe_c499.html" title="User:Mgreenbe">Mgreenbe</a> 22:08, 14 February 2006 (UTC)</dd>
</dl>
<dl>
<dd>
<dl>
<dd>Unless someone is doing <a href="../../../n/o/r/WP%7ENOR_e27a.html" title="WP:NOR">original research</a>, <i>any</i> algorithm that gets entered into Wikipedia should be traceable to a reference. The <i>algorithm</i> should not require any testing or proofs, because the <i>reference</i> is responsible for the correctness of the algorithm. At worst, the algorithm may need to be proof-read against the reference. This is true regardless of whether the algorithm is provided as pseudocode or in a particular language. IMHO the algorithm itself should be defined in pseudocode, for many of the reasons that Leland describes below. I think it's reasonable to have sample implementations of an algorithm that are not traceable to a specific reference (perhaps generated by <a href="../../../c/o/m/WP%7ECOMPSCI_667d.html" title="WP:COMPSCI">WPCS</a> members) where those samples are based on the pseudocode presentation, which <i>is</i> traceable to a reference. Where a sample implementation isn't directly based on the pseudocode (or where no pseudocode is provided), it should be traceable to a specific reference. --<a href="../../../a/l/l/User%7EAllan_McInnes_23d1.html" title="User:Allan McInnes">Allan McInnes</a> <small>(<a href="../../../a/l/l/User_talk%7EAllan_McInnes_8402.html" title="User talk:Allan McInnes">talk</a>)</small> 23:19, 14 February 2006 (UTC)</dd>
</dl>
</dd>
</dl>
<dl>
<dd>While I appreciate your efforts (and particularly the benefits of your experience in this issue) I would like to question how important it is to actually have "executable" code. A few people have cited the need to ensure "correctness" but executability doesn't guarantee correctness, only that the code can be tested - it may still fail for corner cases or cases that haven't been tested. Moreover I would suggest that any algorithm (pseudo)code posted <i>should be checkable by inspection</i> - if it isn't then the algorithm really needs to be rewritten at a higher level to make the important processes clear. I would also suggest that any algorithms really ought to provide a source: given a loose/general enough set of pseudocode guidelines transcription from, and verficiation against, the source pseudocode ought to be trivial.</dd>
</dl>
<dl>
<dd>On the other hand the requirement of executability is a heavy constraint leading code to become potentially mired in necessary implementation details that obscure the important points of the algorithm. Your suggestion of allowing english descriptions of steps that the executable simply prompts the user for is a good one, and does go some distance toward alleviating this issue, but might not always be sufficient. For example, consider the pseudocode for <a href="../../../t/o/p/Topological_sort.html" title="Topological sort">Topological sort</a>: the statement <tt><b>for each</b> node m with an edge e from n to m <b>do</b></tt> is clear enough, but prompting the user to find all the nodes connected by and edge from the given node at each step of the for loop is going to be beyond most people for all but trivial examples, and will still be tedious even for those trivial cases. This could be alleviated by having a suitable data structure declared for the graph, but then the essential points of the algorithm become lost amidst the necessary manipulations of that data structure: it will still be readable but more complicated and less focussed on how the algorithm actually works, which is to say less clear.</dd>
</dl>
<dl>
<dd>In short I believe that "executability" is vastly overrated - the costs are high but the benefits are negligible in comparison. <a href="../../../l/e/l/User%7ELeland_McInnes_a728.html" title="User:Leland McInnes">Leland McInnes</a> 22:31, 14 February 2006 (UTC)</dd>
</dl>
<dl>
<dd>
<dl>
<dd>I also believe executability isn't really all that necessary for the code we deal with here, particularly when we can supply supplementary real-code implementations for that kind of experimentation, but there is a certain faction that is unwilling to adopt standard notation for any sort of code that isn't executable. In addition to allowing the user to specify the semantics of English steps, they could be specified by "hidden code" that actually implements the prose description, as in:</dd>
</dl>
</dd>
</dl>
<pre>
 '''function''' insert(''array'' a, ''int'' length, value) {
     ''set i to index of last element''
&lt;!-- i &amp;larr; length - 1
--&gt;
     '''while''' i &amp;ge; 0 '''and''' a[i] &gt; value
         a[i + 1] &amp;larr; a[i]
         i &amp;larr; i − 1
     a[i + 1] &amp;larr; value
 }
</pre>
<dl>
<dd>
<dl>
<dd>renders as:</dd>
</dl>
</dd>
</dl>
<pre>
<b>function</b> insert(<i>array</i> a, <i>int</i> length, value) {
    <i>set i to index of last element</i>
    <b>while</b> i ≥ 0 <b>and</b> a[i] &gt; value
        a[i + 1] ← a[i]
        i ← i − 1
    a[i + 1] ← value
}
</pre>
<dl>
<dd>
<dl>
<dd>I'm not certain if this generalizes, though. If nothing else I do rather like the idea of a translator for beautification and normalization of pseudocode. <a href="../../../d/e/c/User%7EDeco_20f6.html" title="User:Deco">Deco</a> 22:54, 14 February 2006 (UTC)</dd>
</dl>
</dd>
</dl>
<dl>
<dd>
<dl>
<dd>
<dl>
<dd>I also rather like a code beautifier - it seems like a sensible thing to have around. As to "hidden code" - I'm curious as to how well that will scale, particularly for a lot of mathematical algorithms that are best presented at a very high level. Could we not standardise some method for providing executable implementations (whih can be any a wide variety of languages) on some subpage, or Wikisource, linked to from the article? That seems a moe natural way to provide executable code - Wikipedia isn't meant to be a source repository, while Wikisource is... Surely having a link to a wikisource page with working implementations in a dozen different languages is a far better way to go? <a href="../../../l/e/l/User%7ELeland_McInnes_a728.html" title="User:Leland McInnes">Leland McInnes</a> 23:07, 14 February 2006 (UTC)</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<dl>
<dd>
<dl>
<dd>
<dl>
<dd>
<dl>
<dd>You might want to check out what I did with <a href="../../../q/u/i/Quicksort.html" title="Quicksort">quicksort</a> and quicksort implementations. The concept there was to provide a few representative implementations in the article, and shove the rest out to another article, sharing the common ones in a template. I did this not because I believe implementations belong on Wikipedia, but because people will keep adding them if they're not there (I don't understand this compulsion of adding sample code). The odd thing is that even though there were a gazillion implementations, many of which almost exactly reflected the pseudocode, it didn't discourage overzealous anons from breaking the pseudocode from time to time. But the same problem exists with real code. I personally think there should be a separate code sample repository project under a non-copyleft license, but that's not going to happen (I've tried). And yeah, the idea of executable pseudocode seems increasingly infeasible.&#160;:-) <a href="../../../d/e/c/User%7EDeco_20f6.html" title="User:Deco">Deco</a> 01:02, 15 February 2006 (UTC)</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<dl>
<dd>
<dl>
<dd>
<dl>
<dd>
<dl>
<dd>
<dl>
<dd>In fact what you did with <a href="../../../q/u/i/Quicksort.html" title="Quicksort">quicksort</a> and quicksort implementations has been taken as the model of how to handle such a situation for use in the project style guidelines for <a href="../../../c/o/m/WP%7ECOMPSCI_667d.html" title="WP:COMPSCI">WP:COMPSCI</a>! I feel that it is the most natural way to deal with concrete implementations. Perhaps it should be suggested that all algorithm pages have a prominent link to an implementations page (though maybe link to Wikisource). A lot of thoe pages will, naturally, be blank, but if the link is prominent hopefully it will encourage people to put their implementations there and we can end up with a good code library on Wikisource. <a href="../../../l/e/l/User%7ELeland_McInnes_a728.html" title="User:Leland McInnes">Leland McInnes</a> 02:46, 15 February 2006 (UTC)</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<dl>
<dd>
<dl>
<dd>
<dl>
<dd>
<dl>
<dd>
<dl>
<dd>
<dl>
<dd>Update: Quicksort implementations has been deleted. If additional unencyclopedic implementations are added in the future, feel free to remove them — better to train the contributors about what's appropriate than to encourage them to add anything so long as it stays out of the way. —<tt><a href="../../../d/o/n/User%7EDonhalcon_96f2.html" title="User:Donhalcon">donhalcon</a></tt><sup><a href="../../../d/o/n/User_talk%7EDonhalcon_64c9.html" title="User talk:Donhalcon">〒</a></sup> 21:12, 27 February 2006 (UTC)</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p><a name="LiteratePrograms" id="LiteratePrograms"></a></p>
<h2><span class="editsection">[<a href="../../../a/l/g/Wikipedia_talk%7EAlgorithms_on_Wikipedia_2af5.html" title="Edit section: LiteratePrograms">edit</a>]</span> <span class="mw-headline">LiteratePrograms</span></h2>
<p>Hey all. This is really an advertisement, since this isn't a Wikimedia project, but I thought some of you might be interested in a new wiki I've started using a modified MediaWiki server. It's called <a href="http://literateprograms.org/" class="external text" title="http://literateprograms.org/" rel="nofollow">LiteratePrograms</a>, and is based on the idea of <a href="../../../l/i/t/Literate_programming.html" title="Literate programming">literate programming</a>. The concept is that every article is simultaneously a document and a program; the document describes the program piece by piece, and there's a "download code" tab at the top to automatically reassemble the pieces and download it as ready-to-compile source code. I also added automatic syntax highlighting for the code segments. Here are some sample articles:</p>
<ul>
<li><a href="http://literateprograms.org/Insertion_sort_%28C%2C_simple%29" class="external free" title="http://literateprograms.org/Insertion_sort_%28C%2C_simple%29" rel="nofollow">http://literateprograms.org/Insertion_sort_%28C%2C_simple%29</a></li>
<li><a href="http://literateprograms.org/Turing_machine_simulator_%28C%29" class="external free" title="http://literateprograms.org/Turing_machine_simulator_%28C%29" rel="nofollow">http://literateprograms.org/Turing_machine_simulator_%28C%29</a></li>
</ul>
<p>Any feedback is appreciated. <a href="../../../d/e/c/User%7EDeco_20f6.html" title="User:Deco">Deco</a> 08:51, 2 March 2006 (UTC)</p>
<dl>
<dd>Wow! Great idea! I really like the <code>codeblock</code> tags — it'd be nice if we could get something similar here on WP. I think LP would make a nice complement to WP articles on particular algorithms, and an excellent repository for implementations (and helps to resolve the licensing issues). --<a href="../../../a/l/l/User%7EAllan_McInnes_23d1.html" title="User:Allan McInnes">Allan McInnes</a> <small>(<a href="../../../a/l/l/User_talk%7EAllan_McInnes_8402.html" title="User talk:Allan McInnes">talk</a>)</small> 17:45, 2 March 2006 (UTC)</dd>
</dl>
<dl>
<dd>
<dl>
<dd>Thanks! I was a bit worried that people would see it as attempting to supplant some aspect of Wikipedia, but it really is distinct in purpose. For the most part I link to Wikipedia for descriptions of the concepts, and the articles just describe specific implementations. At the moment the codeblocks are invoking the external perl tool <a href="http://www.palfrader.org/code2html/" class="external text" title="http://www.palfrader.org/code2html/" rel="nofollow">code2html</a>, which probably wouldn't scale for Wikipedia, but it could easily be rewritten in PHP - it just does some simple regular expression search and replace.</dd>
<dd>As for licensing, that's a little tricky. Wikimedia wants everything to be under the GFDL, which I really don't think is an appropriate license for code (no disclaimer of warranty/liability, and big companies are <i>very</i> edgy about copyleft code). Using a less restrictive license permits wider use, but also prevents copying of content from Wikimedia projects without the authors' permission. I've got my wiki set up to add comment blocks with the (very short) MIT/X11 license at the top of each downloaded source file (at least the ones it knows how to write comments in). This is nice in that each file can be redistributed separately, whereas a GFDL'd or GPL'd archive would have to include a LICENSE file that has to be redistributed with each substantial part. The comment text is at <a href="http://literateprograms.org/MediaWiki:Copyrightcomment" class="external text" title="http://literateprograms.org/MediaWiki:Copyrightcomment" rel="nofollow">MediaWiki:Copyrightcomment</a>. <a href="../../../d/e/c/User%7EDeco_20f6.html" title="User:Deco">Deco</a> 19:12, 2 March 2006 (UTC)</dd>
</dl>
</dd>
</dl>
<dl>
<dd>
<dl>
<dd>
<dl>
<dd>That is a rather good idea but once again, we need to choose a programming language, universal enough, and that may be translated easily in other programming languages. The code currently used, that is Python actually, is not easy to translate. The lack of typed variable and return of functions is a real problem. Pascal is a better choice. <a href="../../../s/p/l/User%7ESplang_f846.html" title="User:Splang">Splang</a> 14:13, 17 May 2006 (UTC)</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<dl>
<dd>
<dl>
<dd>
<dl>
<dd>
<dl>
<dd>Huh? The LiteratePrograms wiki currently contains code in about 30 or 40 different languages. Python is one of those languages, but the wiki also includes everything from Assembler to XSL. Pascal is also represented, although there are only a few Pascal programs at present. You are welcome to add more (so long as they are under released under the MIT/X11 license). --<a href="../../../a/l/l/User%7EAllan_McInnes_23d1.html" title="User:Allan McInnes">Allan McInnes</a> <small>(<a href="../../../a/l/l/User_talk%7EAllan_McInnes_8402.html" title="User talk:Allan McInnes">talk</a>)</small> 16:24, 17 May 2006 (UTC)</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<dl>
<dd>
<dl>
<dd>
<dl>
<dd>
<dl>
<dd>
<dl>
<dd>My comment is misplaced and this is confusing. I repeat it in its own section. <a href="../../../s/p/l/User%7ESplang_f846.html" title="User:Splang">Splang</a> 17:27, 21 May 2006 (UTC)</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p><a name="Major_Changes" id="Major_Changes"></a></p>
<h2><span class="editsection">[<a href="../../../a/l/g/Wikipedia_talk%7EAlgorithms_on_Wikipedia_2af5.html" title="Edit section: Major Changes">edit</a>]</span> <span class="mw-headline">Major Changes</span></h2>
<p>This page has been extremely static for some time in a state that could be, at best, described as "provisional", and at worst as "dithering, non-committal, and largely meaningless". With that in mind I have decided to <a href="../../../b/o/l/WP%7EBOLD_e2a0.html" title="WP:BOLD">be bold</a> and import the work from <a href="../../../w/i/k/Wikipedia%7EWikiProject_Computer_science_Manual_of_style_%28computer_science%29_a8c5.html" title="Wikipedia:WikiProject Computer science/Manual of style (computer science)">WikiProject Computer Science Manual of Style</a> to try and get things moving with some assertive guidelines. I'm not suggesting this to be a necessarily finalised version - this topic should remain open for input and discussion. I do hope, however, that discussion can proceed working from this rather more complete set of guidelines. Discussion is most welcome! <a href="../../../l/e/l/User%7ELeland_McInnes_a728.html" title="User:Leland McInnes">Leland McInnes</a> 05:39, 20 May 2006 (UTC)</p>
<dl>
<dd>Shouldn't this page just redirect to the WPCS MoS? —<i><a href="../../../r/2E/_/User%7ER._Koot_c978.html" title="User:R. Koot">Ruud</a></i> 19:21, 21 May 2006 (UTC)</dd>
</dl>
<dl>
<dd>
<dl>
<dd>I viewed that as being a little too bold. WPCS MoS is still just a WikiProject style guide and contains things (like suggestions to link to Literate Programs) that probably aren't ideal for actual Wikipedia policy. Besides, I would rather spend a little more time getting the MoS in good shape and then try and get it promoted to similar footing as <a href="../../../m/a/n/Wikipedia%7EManual_of_Style_%28mathematics%29_835a.html" title="Wikipedia:Manual of Style (mathematics)">Wikipedia:Manual of Style (Mathematics)</a> as a set of official Wikipedia style guidelines rather than doing things piecemeal. <a href="../../../l/e/l/User%7ELeland_McInnes_a728.html" title="User:Leland McInnes">Leland McInnes</a> 05:30, 22 May 2006 (UTC)</dd>
</dl>
</dd>
</dl>
<p><a name="The_programming_language_in_algorithm_articles" id="The_programming_language_in_algorithm_articles"></a></p>
<h2><span class="editsection">[<a href="../../../a/l/g/Wikipedia_talk%7EAlgorithms_on_Wikipedia_2af5.html" title="Edit section: The programming language in algorithm articles">edit</a>]</span> <span class="mw-headline">The programming language in algorithm articles</span></h2>
<p>We need to choose a programming language, universal enough, and that may be translated easily in other programming languages. The code currently used (for example in the <a href="../../../q/u/i/Quicksort.html" title="Quicksort">quicksort</a> page), is Python actually, it is not easy to translate. The lack of typed variable and return of functions is a real problem. Pascal should be a better choice. An XML-like syntax (as that of Scriptol) should be perfect, for universality. <a href="../../../s/p/l/User%7ESplang_f846.html" title="User:Splang">Splang</a> 14:13, 17 May 2006 (UTC)</p>
<dl>
<dd>Er... if you look closely, I think you'll see that the "code" in the <a href="../../../q/u/i/Quicksort.html" title="Quicksort">quicksort</a> is actually not Python at all (unless Python has recently started supporting operations like <code>add pivot to pivotList</code>). The examples are in <a href="../../../p/s/e/Pseudocode.html" title="Pseudocode">pseudocode</a>. If it looks like Python, that might be because Python has often been described as looking like "executable pseudocode"). I'm not sure why you say it's "hard to translate to other languages". The examples look extremely clear an easy to translate to me (note that I did not write the examples - I'm not sure who did). What exactly is the problem with them?</dd>
</dl>
<dl>
<dd>Pseudocode is generally a better choice for describing algorithms than any specific language. It permits the description to focus on the essentials of the algorithm, rather than the quirks of any one language. As for what the pseudocode should look like, you will probably never get precise agreement on that either (look up Derrick Coetzee's wikicode proposal to see what I mean). As it stands, the current <a href="../../../a/l/g/Wikipedia%7EAlgorithms_on_Wikipedia_9ce6.html" title="Wikipedia:Algorithms on Wikipedia">Algorithms on Wikipedia</a> page prescribes some basic guidelines, while leaving the specifics free enough that individual editors can do what makes them happy. If there is a specific piece of pseudocode that you feel looks "too Python-like", and would benefit from being made more "Pascal-like", then feel free to make those changes. --<a href="../../../a/l/l/User%7EAllan_McInnes_23d1.html" title="User:Allan McInnes">Allan McInnes</a> <small>(<a href="../../../a/l/l/User_talk%7EAllan_McInnes_8402.html" title="User talk:Allan McInnes">talk</a>)</small> 18:57, 21 May 2006 (UTC)</dd>
</dl>
<p><a name="Pseudocode_syntax" id="Pseudocode_syntax"></a></p>
<h2><span class="editsection">[<a href="../../../a/l/g/Wikipedia_talk%7EAlgorithms_on_Wikipedia_2af5.html" title="Edit section: Pseudocode syntax">edit</a>]</span> <span class="mw-headline">Pseudocode syntax</span></h2>
<p>The content here overlaps with <a href="../../../w/i/k/Wikipedia%7EWikiProject_Computer_science_Manual_of_style_%28computer_science%29_a8c5.html" title="Wikipedia:WikiProject Computer science/Manual of style (computer science)">Wikipedia:WikiProject Computer science/Manual of style (computer science)</a>. Which should be the main source? I added the <i>integer division operator</i> to the table. Considering that we have floor and ceiling operators, it may be useful to distinguish. But now I don't know where I should be changing.</p>
<p>The <b>algorithm</b> keyword is a bit redundant. It has the same role as <b>function</b>. I think we should remove it from the Ford-Fulkerson example.</p>
<p>I think we should have a notation for arrays, lists and sets, together with proper operators (especially for sets; that would simplify some parsing algorithms when their correctness proof uses set theory).</p>
<p>And what about increment operators? For example, <a href="../../../c/o/u/Counting_sort.html" title="Counting sort">Counting sort</a> currently (26 January 2007) has a C sample code. It's a very simple algorithm, but without <b>++</b> and <b>+=</b> it can be very confusing. This</p>
<pre>
counts[i] += counts[ i - 1 ];
++counts[ A[i] - min ];
</pre>
<p>would be</p>
<pre>
counts[i] ← counts[i] + counts[ i - 1 ];
counts[ A[i] - min ] ← counts[ A[i] - min ] + 1;
</pre>
<p>Does anyone favor <b>increment</b>, <b>a ← a + 1</b> or <b>inc(a)</b> over <b>a++</b>? What about <b>+=</b>? <a href="../../../d/a/n/User%7EDanielKO_2531.html" title="User:DanielKO">DanielKO</a> 14:00, 27 January 2007 (UTC)</p>
<dl>
<dd>I think <a href="../../../w/i/k/Wikipedia%7EWikiProject_Computer_science_Manual_of_style_%28computer_science%29_a8c5.html" title="Wikipedia:WikiProject Computer science/Manual of style (computer science)">Wikipedia:WikiProject Computer science/Manual of style (computer science)</a> and this page are expeted to diverse slowly. Each has their own demands that are slightly different. If you feel a change is needed in both, then make it to both. If not then make it on whichever seems appropriate.</dd>
</dl>
<dl>
<dd>As to the <b>algorithm</b> keyword - see it as being akin to the <b>procedure</b> keyword, and thus, in some sense, distinguishable from the <b>function</b> keyword. Some might argue that that's a subtle point (though in practice it really isn't), but I think the real point is that the pseudocode guidelines are just that: guidlines; the aim is to provide flexibility and let people do what they want, but provide enough general stylistic consistency that things don't get too wildly divergent.</dd>
</dl>
<dl>
<dd>As to notation for arrays lists and sets - I personally don't want to get too far into nailing down hard syntax. That was lies the problems of the Wikicode debate. I think most people, in general, are going to pick suitable nottion themselves. The real judging point is that whatever notation is chosen, it should be relatively clear, or makde clear, in the article in which it appears.</dd>
</dl>
<dl>
<dd>I'm not a fan of increment operators for pseudocode. With pseudocode the aim shoul be clarity and no requirement for knowledge of any particular language - and increment operators are a language specfic feature. I think a great many users, particularly non-programmers who simply want to understand an algorithm, will find the slightly longer version that mkes the operation explicit far more clear than increment operator notation. <a href="../../../l/e/l/User%7ELeland_McInnes_a728.html" title="User:Leland McInnes">Leland McInnes</a> 17:13, 27 January 2007 (UTC)</dd>
</dl>
<dl>
<dd>
<dl>
<dd>I'd add that increment operators and other side-effecting operators, while convenient, are notorious for introducing unexpected behavior into programs. Being explicit about where values are being assigned (i.e. the <b>a ← a + 1</b> form) is probably a safer approach. --<a href="../../../a/l/l/User%7EAllan_McInnes_23d1.html" title="User:Allan McInnes">Allan McInnes</a> <small>(<a href="../../../a/l/l/User_talk%7EAllan_McInnes_8402.html" title="User talk:Allan McInnes">talk</a>)</small> 18:42, 27 January 2007 (UTC)</dd>
</dl>
</dd>
</dl>
<p>I've changed the page to recommend "<code>a <b>div</b> b</code>" over "<code>a ÷ b</code>", since — at least in the United States public school system — "÷" and "/" are both synonyms for "divided by". There's nothing inherently "integer" about the line-and-two-dots division symbol. On the other hand, "<code><b>div</b></code>" is used to mean "integer division" in several real-world programming languages.</p>
<p>Of course, there's still the question of whether <code>-1 <b>div</b> 2</code> is <code>-1</code> or <code>0</code>, but that's a question better left unanswered; let the individual algorithm descriptions pick their own rounding modes if they find it necessary.</p>
<p>My two cents on increment operators: It's obvious to me that "<code>a&#160;:= a + 1</code>" is clearer than anything you could possibly dream up as a pseudosyntax for "increment". Even in <a href="../../../c/_/%28/C_%28programming_language%29.html" title="C (programming language)">C</a>, you should prefer "<code>blah[baz]-&gt;foo += 1;</code>" to "<code>++blah[baz]-&gt;foo</code>", for clarity, and also to prevent confusion on the reader's part about whether the prefix or postfix operator binds tighter. (Yes, C programmers know which; but do Wikipedia readers?)</p>
<p>The left-arrow "<code>←</code>" should <i><b>never</b></i> be used as a shorthand for assignment; it looks too much like a minus sign in <a href="../../../c/o/u/Courier_New_99d3.html" title="Courier New">Courier New</a>, the most common font with which &lt;code&gt; tags will be displayed in a browser. Use the universally recognized (thanks to <a href="../../../n/i/k/Niklaus_Wirth_8ae8.html" title="Niklaus Wirth">Wirth</a>) assignment operator "<code>:=</code>" instead. --<a href="../../../q/u/u/User%7EQuuxplusone_9b50.html" title="User:Quuxplusone">Quuxplusone</a> 03:01, 7 March 2007 (UTC)</p>

<div class="printfooter">
Retrieved from "<a href="http://en.wikipedia.org../../../a/l/g/Wikipedia_talk%7EAlgorithms_on_Wikipedia_2af5.html">http://en.wikipedia.org../../../a/l/g/Wikipedia_talk%7EAlgorithms_on_Wikipedia_2af5.html</a>"</div>
	    	    <!-- end content -->
	    <div class="visualClear"></div>
	  </div>
	</div>
      </div>
      <div id="column-one">
	<div id="p-cactions" class="portlet">
	  <h5>Views</h5>
	  <ul>
	    <li id="ca-nstab-project"
	       	       ><a href="../../../a/l/g/Wikipedia%7EAlgorithms_on_Wikipedia_9ce6.html">Project page</a></li><li id="ca-talk"
	       class="selected"	       ><a href="../../../a/l/g/Wikipedia_talk%7EAlgorithms_on_Wikipedia_2af5.html">Discussion</a></li><li id="ca-current"
	       	       ><a href="http://en.wikipedia.org/wiki/Wikipedia_talk:Algorithms_on_Wikipedia">Current revision</a></li>	  </ul>
	</div>
	<div class="portlet" id="p-logo">
	  <a style="background-image: url(../../../images/wiki-en.png);"
	    href="../../../index.html"
	    title="Main Page"></a>
	</div>
	<script type="text/javascript"> if (window.isMSIE55) fixalpha(); </script>
		<div class='portlet' id='p-navigation'>
	  <h5>Navigation</h5>
	  <div class='pBody'>
	    <ul>
	    	      <li id="n-Main-page"><a href="../../../index.html">Main page</a></li>
	     	      <li id="n-Contents"><a href="../../../c/o/n/Wikipedia%7EContents_3181.html">Contents</a></li>
	     	      <li id="n-Featured-content"><a href="../../../f/e/a/Wikipedia%7EFeatured_content_24ba.html">Featured content</a></li>
	     	      <li id="n-currentevents"><a href="../../../c/u/r/Portal%7ECurrent_events_bb60.html">Current events</a></li>
	     	    </ul>
	  </div>
	</div>
		<div class='portlet' id='p-interaction'>
	  <h5>interaction</h5>
	  <div class='pBody'>
	    <ul>
	    	      <li id="n-About-Wikipedia"><a href="../../../a/b/o/Wikipedia%7EAbout_8d82.html">About Wikipedia</a></li>
	     	      <li id="n-portal"><a href="../../../c/o/m/Wikipedia%7ECommunity_Portal_6a3c.html">Community portal</a></li>
	     	      <li id="n-contact"><a href="../../../c/o/n/Wikipedia%7EContact_us_afd6.html">Contact us</a></li>
	     	      <li id="n-sitesupport"><a href="http://wikimediafoundation.org/wiki/Fundraising">Make a donation</a></li>
	     	      <li id="n-help"><a href="../../../c/o/n/Help%7EContents_22de.html">Help</a></li>
	     	    </ul>
	  </div>
	</div>
		<div id="p-search" class="portlet">
	  <h5><label for="searchInput">Search</label></h5>
	  <div id="searchBody" class="pBody">
	    <form action="javascript:goToStatic(3)" id="searchform"><div>
	      <input id="searchInput" name="search" type="text"
	        accesskey="f" value="" />
	      <input type='submit' name="go" class="searchButton" id="searchGoButton"
	        value="Go" />
	    </div></form>
	  </div>
	</div>
	      </div><!-- end of the left (by default at least) column -->
      <div class="visualClear"></div>
      <div id="footer">
    <div id="f-poweredbyico"><a href="http://www.mediawiki.org/"><img src="../../../skins/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" /></a></div>	<div id="f-copyrightico"><a href="http://wikimediafoundation.org/"><img src="../../../images/wikimedia-button.png" border="0" alt="Wikimedia Foundation"/></a></div>	<ul id="f-list">
	  	  	  <li id="f-credits">This page was last modified 03:01, 7 March 2007 by Wikipedia user <a href="../../../q/u/u/User%7EQuuxplusone_9b50.html" title="User:Quuxplusone">Quuxplusone</a>. Based on work by Wikipedia user(s) <a href="../../../a/l/l/User%7EAllan_McInnes_23d1.html" title="User:Allan McInnes">Allan McInnes</a>, <a href="../../../l/e/l/User%7ELeland_McInnes_a728.html" title="User:Leland McInnes">Leland McInnes</a>, <a href="../../../d/a/n/User%7EDanielKO_2531.html" title="User:DanielKO">DanielKO</a>, <a href="../../../r/h/w/User%7ERhwawn_f1df.html" title="User:Rhwawn">Rhwawn</a>, <a href="../../../r/u/u/User%7ERuud_Koot_88b0.html" title="User:Ruud Koot">Ruud Koot</a>, <a href="../../../s/p/l/User%7ESplang_f846.html" title="User:Splang">Splang</a>, <a href="../../../d/c/o/User%7EDcoetzee_a2a7.html" title="User:Dcoetzee">Dcoetzee</a>, <a href="../../../d/o/n/User%7EDonhalcon_96f2.html" title="User:Donhalcon">Donhalcon</a>, <a href="../../../m/g/r/User%7EMgreenbe_c499.html" title="User:Mgreenbe">Mgreenbe</a>, <a href="../../../e/a/t/User%7EEatMyShortz_1fd5.html" title="User:EatMyShortz">EatMyShortz</a>, <a href="../../../g/u/a/User%7EGuanabot_b902.html" title="User:Guanabot">Guanabot</a>, <a href="../../../t/e/x/User%7ETexture_fd4f.html" title="User:Texture">Texture</a>, <a href="../../../%C3%A6/v/a/User%7E%C3%86var_Arnfj%C3%B6r%C3%B0_Bjarmason_03c5.html" title="User:Ævar Arnfjörð Bjarmason">Ævar Arnfjörð Bjarmason</a>, <a href="../../../m/a/x/User%7EMaximus_Rex_f7db.html" title="User:Maximus Rex">Maximus Rex</a>, <a href="../../../s/t/e/User%7EStephen_Gilbert_b934.html" title="User:Stephen Gilbert">Stephen Gilbert</a>, <a href="../../../k/o/y/User%7EKoyaanis_Qatsi_7ab5.html" title="User:Koyaanis Qatsi">Koyaanis Qatsi</a>, <a href="../../../c/y/d/User%7ECYD_b425.html" title="User:CYD">CYD</a>, <a href="../../../l/e/e/User%7ELee_Daniel_Crocker_4538.html" title="User:Lee Daniel Crocker">Lee Daniel Crocker</a>, <a href="../../../t/a/w/User%7ETaw_8bc0.html" title="User:Taw">Taw</a>, <a href="../../../l/c/_/User%7ELC_0e98.html" title="User:LC">LC</a>, <a href="../../../a/x/e/User%7EAxelBoldt_4306.html" title="User:AxelBoldt">AxelBoldt</a> and <a href="../../../b/e/n/User%7EBenBaker_64fa.html" title="User:BenBaker">BenBaker</a> and Anonymous user(s) of Wikipedia.</li>	  <li id="f-copyright">All text is available under the terms of the <a class='internal' href="../../../t/e/x/Wikipedia%7EText_of_the_GNU_Free_Documentation_License_702a.html" title="Wikipedia:Text of the GNU Free Documentation License">GNU Free Documentation License</a>. (See <b><a class='internal' href="../../../c/o/p/Wikipedia%7ECopyrights_92c4.html" title="Wikipedia:Copyrights">Copyrights</a></b> for details.) <br /> Wikipedia&reg; is a registered trademark of the <a href="http://www.wikimediafoundation.org">Wikimedia Foundation, Inc</a>., a US-registered <a class='internal' href="../../../5/0/1/501%28c%29.html#501.28c.29.283.29" title="501(c)(3)">501(c)(3)</a> <a href="http://wikimediafoundation.org/wiki/Deductibility_of_donations">tax-deductible</a> <a class='internal' href="../../../n/o/n/Non-profit_organization.html" title="Non-profit organization">nonprofit</a> <a href="../../../c/h/a/Charitable_organization.html" title="Charitable organization">charity</a>.<br /></li>	  <li id="f-about"><a href="../../../a/b/o/Wikipedia%7EAbout_8d82.html" title="Wikipedia:About">About Wikipedia</a></li>	  <li id="f-disclaimer"><a href="../../../g/e/n/Wikipedia%7EGeneral_disclaimer_3e44.html" title="Wikipedia:General disclaimer">Disclaimers</a></li>	  	</ul>
      </div>
    </div>
  </body>
</html>
