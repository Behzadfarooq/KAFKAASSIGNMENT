<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    		<meta name="keywords" content="User:Armandeh/diff.js,Bypass your cache" />
		<link rel="shortcut icon" href="/favicon.ico" />
		<link rel="search" type="application/opensearchdescription+xml" href="/w/opensearch_desc.php" title="Wikipedia (English)" />
		<link rel="copyright" href="../../../COPYING.html" />
    <title>User:Armandeh/diff.js - Wikipedia, the free encyclopedia</title>
    <style type="text/css">/*<![CDATA[*/ @import "../../../skins/htmldump/main.css"; /*]]>*/</style>
    <link rel="stylesheet" type="text/css" media="print" href="../../../skins/common/commonPrint.css" />
    <!--[if lt IE 5.5000]><style type="text/css">@import "../../../skins/monobook/IE50Fixes.css";</style><![endif]-->
    <!--[if IE 5.5000]><style type="text/css">@import "../../../skins/monobook/IE55Fixes.css";</style><![endif]-->
    <!--[if IE 6]><style type="text/css">@import "../../../skins/monobook/IE60Fixes.css";</style><![endif]-->
    <!--[if IE]><script type="text/javascript" src="../../../skins/common/IEFixes.js"></script>
    <meta http-equiv="imagetoolbar" content="no" /><![endif]-->
    <script type="text/javascript" src="../../../skins/common/wikibits.js"></script>
    <script type="text/javascript" src="../../../skins/htmldump/md5.js"></script>
    <script type="text/javascript" src="../../../skins/htmldump/utf8.js"></script>
    <script type="text/javascript" src="../../../skins/htmldump/lookup.js"></script>
    <script type="text/javascript" src="../../../raw/gen.js"></script>        <style type="text/css">/*<![CDATA[*/
@import "../../../raw/MediaWiki%7ECommon.css";
@import "../../../raw/MediaWiki%7EMonobook.css";
@import "../../../raw/gen.css";
/*]]>*/</style>          </head>
  <body
    class="ns-2">
    <div id="globalWrapper">
      <div id="column-content">
	<div id="content">
	  <a name="top" id="contentTop"></a>
	        <h1 class="firstHeading">User:Armandeh/diff.js</h1>
	  <div id="bodyContent">
	    <h3 id="siteSub">From Wikipedia, the free encyclopedia</h3>
	    <div id="contentSub"><span class="subpages">&lt; <a href="../../../a/r/m/User%7EArmandeh_d115.html" title="User:Armandeh">User:Armandeh</a></span></div>
	    	    <div class="usermessage">You have <a href="../../../1/2/7/User_talk%7E127.0.0.1.html" title="User talk:127.0.0.1">new messages</a> (<a href="../../../1/2/7/User_talk%7E127.0.0.1.html" title="User talk:127.0.0.1">last change</a>).</div>	    <!-- start content -->
	    <p><span id="clearyourcache"><b>Note:</b> After saving, you have to <a href="../../../b/y/p/Wikipedia%7EBypass_your_cache_1dae.html" title="Wikipedia:Bypass your cache">bypass your browser's cache</a> to see the changes. <b>Firefox/Mozilla/Safari:</b> hold down <i>Shift</i> while clicking <i>Reload</i> (or press <i>Ctrl-Shift-R</i>), <b>Internet Explorer:</b> press <i>Ctrl-F5</i>, <b>Opera/Konqueror:</b> press <i>F5</i>. 
</span>
</p><pre>/* &lt;pre&gt;&lt;nowiki&gt; */


/*

JavaScript diff algorithm by [[User:Cacycle]] (http://en.wikipedia.org/wiki/User_talk:Cacycle).
Outputs html/css-formatted new text with changes like deletions, inserts, and block moves highlighted.
The program works only for the mozilla browsers Mozilla, Mozilla Firefox, and Mozilla SeaMonkey.
The code is currently under active development and might change rapidly.

An implementation of:
Paul Heckel: A technique for isolating differences between files
Communications of the ACM 21(4):264 (1978)
http://doi.acm.org/10.1145/359460.359467

* Word types have been optimized for Wikipedia source texts
* Additional post-pass 5 code for resolving islands caused by adding
  two common words at the end of sequences of common words
* Additional detection of block borders and color coding of moved blocks and their original position

This code is used by [[User:Cacycle/editor.js]] ([[User:Cacycle/editor]]).

Usage: var htmlText = stringDiff(oldText, newText);
To install the style sheets you have to run: SetupDiff(); (not needed for editor)

This code has been released into the public domain.

Datastructures:

text: an object that holds all text related datastructures
	.newWords: consecutive words of the new text (N)
	.oldWords: consecutive words of the old text (O)
	.newToOld: array of corresponding word number in old text (NA)
	.oldToNew: array of corresponding word number in new text (OA)
	.message:  output message for testing purposes

symbol['word']: symbol table for passes 1 - 3, holds words as a hash
	.newCtr:  new word occurences counter (NC)
	.oldCtr:  old word occurences counter (OC)
	.toNew:   table last old word number
	.toOld:   last new word number (OLNA)

block: an object that holds block move information
	blocks indexed after new text:
	.newStart:  new text word number of start of this block
	.newLength: element number of this block including non-words
	.newWords:  true word number of this block
	.newNumber: corresponding block index in old text
	.newBlock:  moved-block-number of a block that has been moved here
	.newLeft:   moved-block-number of a block that has been moved from this border leftwards
	.newRight:  moved-block-number of a block that has been moved from this border rightwards
	.newLeftIndex:  index number of a block that has been moved from this border leftwards
	.newRightIndex: index number of a block that has been moved from this border rightwards
	blocks indexed after old text:
	.oldStart:  word number of start of this block
	.oldToNew:  corresponding new text word number of start
	.oldLength: element number of this block including non-words
	.oldWords:  true word number of this block

*/

// css for diff view elements
var styleDelete = styleDelete || 'font-weight: normal; text-decoration: none; color: #ffffff; background-color: #990033;';
var styleInsert = styleInsert || 'font-weight: normal; text-decoration: none; color: #ffffff; background-color: #009933;';
var styleMoved  = styleMoved  || 'font-weight: bold; vertical-align: text-bottom; font-size: xx-small; padding: 0; border: solid 1px';
var styleColor  = styleColor  || [
	'background-color: #ffff44;',
	'background-color: #b0ff90;',
	'background-color: #ffcc99;',
	'background-color: #99ffff;',
	'background-color: #99ccff;',
	'background-color: #cc99ff;',
	'background-color: #ff99cc;',
	'background-color: #ffd040;',
	'background-color: #d0d0d0;'
];

// html for block move indicators, {block} is replaced by the block number
var htmlMovedRight = htmlMovedRight || '&lt;input type=&quot;button&quot; value=&quot;&amp;gt;&quot; class=&quot;diffMoved{block}&quot;&gt;';
var htmlMovedLeft  = htmlMovedLeft  || '&lt;input type=&quot;button&quot; value=&quot;&amp;lt;&quot; class=&quot;diffMoved{block}&quot;&gt;';
var htmlBlockStart = htmlBlockStart || '&lt;span class=&quot;diffBlock{block}&quot;&gt;';
var htmlBlockEnd   = htmlBlockEnd   || '&lt;/span&gt;';

// minimal number of real words for a moved block (0 for always displaying block move indicators)
var blockMinLength = blockMinLength || 3;

// exclude identical sequence starts and endings from highlighting of changed text
var wordDiff = wordDiff || true;

// enable recursive diff to resolve problematic sequences
var recursiveDiff = recursiveDiff || true;

// show block moves
var showBlockMoves = showBlockMoves || true;

// html tag to be used for insertions (ins or span)
var insTag = insTag || 'span';

// html tag to be used for deletions (del or span)
var delTag = delTag || 'span';


// global variables
var i;
var j;
var m;
var n;
var diffStyleMax;


// SetupDiff: install style sheets
function SetupDiff() {

	var insert = document.getElementsByTagName('head')[0];
	if (insert != null) {
		var html = '';
		html += '&lt;style type=&quot;text/css&quot;&gt;\n';
		html += '.diffDelete { ' + styleDelete + ' }\n';
		html += '.diffInsert { ' + styleInsert + ' }\n';
		i = 0;
		while (styleColor[i] != null) {
			html += '.diffBlock' + (i + 1) + ' { ' + styleColor[i] + ' }\n';
			html += '.diffMoved' + (i + 1) + ' { ' + styleColor[i] + ' ' + styleMoved + ' }\n';
			i ++;
		}
		diffStyleMax = i;
		html += '&lt;/style&gt;\n';
		insert.innerHTML += html;
	}
	return;
}


// StringDiff: main program
// input: oldText, newText, strings containing the texts
// returns: html diff

function StringDiff(oldText, newText) {

	var text = {};
	text.newWords = [];
	text.oldWords = [];
	text.newToOld = [];
	text.oldToNew = [];
	text.message = '';
	var block = {};
	var outText;

// split new and old text into words
	SplitText(oldText, newText, text);

// calculate diff information
	TextDiff(text);

//detect block borders and moved blocks
	DetectBlocks(text, block);

// process diff data into formatted html text
	outText = DiffToHtml(text, block);

	return(outText);
}


// SplitText: split new and old text into words
// input: oldText, newText, strings containing the texts
// changes: text.newWords and text.oldWords, arrays containing the texts in arrays of words

function SplitText(oldText, newText, text) {

// convert strange spaces
	oldText = oldText.replace(/[\t\v\u00A0\u2028\u2029]+/g, ' ');
	newText = newText.replace(/[\t\v\u00A0\u2028\u2029]+/g, ' ');

// split old text into words
	var result;
	do {

//           /     |    |    |    |    |   |  |     |   |  |  |    |    |    | /
		result = /[\w]+|\[\[|\]\]|\{\{|\}\}|\n+| +|&amp;\w+;|'''|''|=+|\{\||\|\}|\|\-|./g.exec(oldText);
		if (result != null) {
			text.oldWords.push(result[0]);
		}
	} while (result != null);

// split new text into words
	do {
		result = /[\w]+|\[\[|\]\]|\{\{|\}\}|\n+| +|&amp;\w+;|'''|''|=+|\{\||\|\}|\|\-|./g.exec(newText);
		if (result != null) {
			text.newWords.push(result[0]);
		}
	} while (result != null);

	return;
}


// TextDiff: calculate diff information
// input: text.newWords and text.oldWords, arrays containing the texts in arrays of words
// optionally for recursive calls: newStart, newEnd, oldStart, oldEnd, recursionLevel
// changes: text.newToOld and text.oldToNew, containing the line numbers in the other version

function TextDiff(text, newStart, newEnd, oldStart, oldEnd, recursionLevel) {

	symbol = new Object();
	symbol.newCtr = [];
	symbol.oldCtr = [];
	symbol.toNew = [];
	symbol.toOld = [];

// set defaults
	newStart = newStart || 0;
	newEnd = newEnd || text.newWords.length;
	oldStart = oldStart || 0;
	oldEnd = oldEnd || text.oldWords.length;
	recursionLevel = recursionLevel || 0;

// pass 1: parse new text into symbol table s

	var word;
	for (i = newStart; i &lt; newEnd; i ++) {
		word = text.newWords[i];

// add new entry to symbol table
		if ( symbol[word] == null) {
			symbol[word] = { newCtr: 0, oldCtr: 0, toNew: null, toOld: null };
		}

// increment symbol table word counter for new text
		symbol[word].newCtr ++;

// add last word number in new text
		symbol[word].toNew = i;
	}

// pass 2: parse old text into symbol table

	for (j = oldStart; j &lt; oldEnd; j ++) {
		word = text.oldWords[j];

// add new entry to symbol table
		if ( symbol[word] == null) {
			symbol[word] = { newCtr: 0, oldCtr: 0, toNew: null, toOld: null };
		}

// increment symbol table word counter for old text
		symbol[word].oldCtr ++;

// add last word number in old text
		symbol[word].toOld = j;
	}

// pass 3: connect unique words

	for (i in symbol) {

// find words in the symbol table that occur only once in both versions
		if ( (symbol[i].newCtr == 1) &amp;&amp; (symbol[i].oldCtr == 1) ) {
			var toNew = symbol[i].toNew;
			var toOld = symbol[i].toOld;

// do not use spaces as unique markers
			if ( ! /\s/.test( text.newWords[toNew] ) ) {

// connect from new to old and from old to new
				text.newToOld[toNew] = toOld;
				text.oldToNew[toOld] = toNew;
			}
		}
	}

// pass 4: connect following identical words downwards

	for (i = newStart; i &lt; newEnd - 1; i ++) {

// find already connected pairs
		if (text.newToOld[i] != null) {
			j = text.newToOld[i];

// check if the following words are not yet connected
			if ( (text.newToOld[i + 1] == null) &amp;&amp; (text.oldToNew[j + 1] == null) ) {

// if the following words are the same connect them
				if ( text.newWords[i + 1] == text.oldWords[j + 1] ) {
					text.newToOld[i + 1] = j + 1;
					text.oldToNew[j + 1] = i + 1;
				}
			}
		}
	}

// pass 5: connect following identical words upwards

	for (i = newEnd - 1; i &gt; newStart; i --) {

// find already connected pairs
		if (text.newToOld[i] != null) {
			j = text.newToOld[i];

// check if the preceeding words are not yet connected
			if ( (text.newToOld[i - 1] == null) &amp;&amp; (text.oldToNew[j - 1] == null) ) {

// if the preceeding words are the same connect them
				if ( text.newWords[i - 1] == text.oldWords[j - 1] ) {
					text.newToOld[i - 1] = j - 1;
					text.oldToNew[j - 1] = i - 1;
				}
			}
		}
	}

// recursively diff still unresolved regions downwards

	if (recursiveDiff &amp;&amp; true) {
		i = newStart;
		j = oldStart;
		while (i &lt; newEnd) {
			if (text.newToOld[i - 1] != null) {
				j = text.newToOld[i - 1] + 1;
			}

// check for the start of an unresolved sequence
			if ( (text.newToOld[i] == null) &amp;&amp; (text.oldToNew[j] == null) ) {

// determine the ends of the sequences
				var iStart = i;
				var iEnd = i;
				while ( (text.newToOld[iEnd] == null) &amp;&amp; (iEnd &lt; newEnd) ) {
					iEnd ++;
				}
				var iLength = iEnd - iStart;

				var jStart = j;
				var jEnd = j;
				while ( (text.oldToNew[jEnd] == null) &amp;&amp; (jEnd &lt; oldEnd) ) {
					jEnd ++;
				}
				var jLength = jEnd - jStart;

// recursively diff the unresolved sequence
				if ( (iLength &gt; 0) &amp;&amp; (jLength &gt; 0) ) {
					if ( (iLength &gt; 1) || (jLength &gt; 1) ) {
						if ( (iStart != newStart) || (iEnd != newEnd) || (jStart != oldStart) || (jEnd != oldEnd) ) {
							TextDiff(text, iStart, iEnd, jStart, jEnd, recursionLevel + 1);
						}
					}
				}
				i = iEnd;
			}
			else {
				i ++;
			}
		}
	}

// recursively diff still unresolved regions upwards

	if (recursiveDiff &amp;&amp; true) {
		i = newEnd - 1;
		j = oldEnd - 1;
		while (i &gt;= newStart) {
			if (text.newToOld[i + 1] != null) {
				j = text.newToOld[i + 1] - 1;
			}

// check for the start of an unresolved sequence
			if ( (text.newToOld[i] == null) &amp;&amp; (text.oldToNew[j] == null) ) {

// determine the ends of the sequences
				var iStart = i;
				var iEnd = i + 1;
				while ( (text.newToOld[iStart - 1] == null) &amp;&amp; (iStart &gt;= newStart) ) {
					iStart --;
				}
				var iLength = iEnd - iStart;

				var jStart = j;
				var jEnd = j + 1;
				while ( (text.oldToNew[jStart - 1] == null) &amp;&amp; (jStart &gt;= oldStart) ) {
					jStart --;
				}
				var jLength = jEnd - jStart;

// recursively diff the unresolved sequence
				if ( (iLength &gt; 0) &amp;&amp; (jLength &gt; 0) ) {
					if ( (iLength &gt; 1) || (jLength &gt; 1) ) {
						if ( (iStart != newStart) || (iEnd != newEnd) || (jStart != oldStart) || (jEnd != oldEnd) ) {


							TextDiff(text, iStart, iEnd, jStart, jEnd, recursionLevel + 1);
						}
					}
				}
				i = iStart - 1;
			}
			else {
				i --;
			}
		}
	}
	return;
}


// DiffToHtml: process diff data into formatted html text
// input: text.newWords and text.oldWords, arrays containing the texts in arrays of words
//   text.newToOld and text.oldToNew, containing the line numbers in the other version
//   block data structure
// returns: outText, a html string

function DiffToHtml(text, block) {

	var outText = text.message;

	var blockNumber = 0;
	i = 0;
	j = 0;
	do {
		var movedIndex = [];
		var movedBlock = [];
		var movedLeft = [];
		var blockText = '';
		var identText = '';
		var delText = '';
		var insText = '';
		var identStart = '';
		var identEnd = '';

// detect block boundary
		if ( (text.newToOld[i] != j) || (blockNumber == 0 ) ) {
			if ( ( (text.newToOld[i] != null) || (i &gt;= text.newWords.length) ) &amp;&amp; ( (text.oldToNew[j] != null) || (j &gt;= text.oldWords.length) ) ) {

// block moved right
				var moved = block.newRight[blockNumber];
				if (moved &gt; 0) {
					var index = block.newRightIndex[blockNumber];
					movedIndex.push(index);
					movedBlock.push(moved);
					movedLeft.push(false);
				}

// block moved left
				moved = block.newLeft[blockNumber];
				if (moved &gt; 0) {
					var index = block.newLeftIndex[blockNumber];
					movedIndex.push(index);
					movedBlock.push(moved);
					movedLeft.push(true);
				}

// check if a block starts here
				moved = block.newBlock[blockNumber];
				if (moved &gt; 0) {

// mark block as inserted text
					if (block.newWords[blockNumber] &lt; blockMinLength) {
						identStart = '&lt;' + insTag + ' class=&quot;diffInsert&quot;&gt;';
						identEnd = '&lt;/' + insTag + '&gt;';
					}

// mark block by color
					else {
						if (moved &gt;= diffStyleMax) {
							moved = diffStyleMax;
						}
						identStart = htmlBlockStart.replace(/\{block\}/, moved);
						identEnd = htmlBlockEnd.replace(/\{block\}/, moved);
					}
				}

				if (i &gt;= text.newWords.length) {
					i ++;
				}
				else {
					j = text.newToOld[i];
					blockNumber ++;
				}
			}
		}

// get the correct order if moved to the left as well as to the right from here
		if (movedIndex.length == 2) {
			if (movedIndex[0] &gt; movedIndex[1]) {
				movedIndex.reverse();
				movedBlock.reverse();
				movedLeft.reverse();
			}
		}

// handle left and right block moves from this position
		for (m = 0; m &lt; movedIndex.length; m ++) {

// insert the block as deleted text
			if (block.newWords[ movedIndex[m] ] &lt; blockMinLength) {
				var movedStart = block.newStart[ movedIndex[m] ];
				var movedLength = block.newLength[ movedIndex[m] ];
				var str = '';
				for (n = movedStart; n &lt; movedStart + movedLength; n ++) {
					str += text.newWords[n];
				}
				str = str.replace(/\n/g, '&amp;para;&lt;br&gt;');
				blockText += '&lt;' + delTag + ' class=&quot;diffDelete&quot;&gt;' + Escape(str) + '&lt;/' + delTag + '&gt;';
			}

// add a placeholder / move direction indicator
			else {
				if (movedBlock[m] &gt;= diffStyleMax) {
					movedBlock[m] = diffStyleMax;
				}
				if (movedLeft[m]) {
					blockText += htmlMovedLeft.replace(/\{block\}/, movedBlock[m]);
				}
				else {
					blockText += htmlMovedRight.replace(/\{block\}/, movedBlock[m]);
				}
			}
		}

// collect consecutive identical text
		while ( (i &lt; text.newWords.length) &amp;&amp; (j &lt; text.oldWords.length) ) {
			if ( (text.newToOld[i] == null) || (text.oldToNew[j] == null) ) {
				break;
			}
			if (text.newToOld[i] != j) {
				break;
			}
			identText += text.newWords[i];
			i ++;
			j ++;
		}

// collect consecutive deletions
		while ( (text.oldToNew[j] == null) &amp;&amp; (j &lt; text.oldWords.length) ) {
			delText += text.oldWords[j];
			j ++;
		}

// collect consecutive inserts
		while ( (text.newToOld[i] == null) &amp;&amp; (i &lt; text.newWords.length) ) {
			insText += text.newWords[i];
			i ++;
		}

// remove leading and trailing similarities betweein delText and ins from highlighting
		var preText = '';
		var postText = '';
		if (wordDiff) {
			if ( (delText != '') &amp;&amp; (insText != '') ) {

// remove leading similarities
				while ( delText.charAt(0) == insText.charAt(0) ) {
					preText = preText + delText.charAt(0);
					delText = delText.substr(1);
					insText = insText.substr(1);
				}

// remove trailing similarities
				while ( delText.charAt(delText.length - 1) == insText.charAt(insText.length - 1) ) {
					postText = delText.charAt(delText.length - 1) + postText;
					delText = delText.substr(0, delText.length - 1);
					insText = insText.substr(0, insText.length - 1);
				}
			}
		}

// output the identical text, deletions and inserts
		if (blockText != '') {
			outText += blockText;
		}
		if (identText != '') {
			outText += identStart + Escape(identText) + identEnd;
		}
		outText += preText;
		if (delText != '') {
			delText = '&lt;' + delTag + ' class=&quot;diffDelete&quot;&gt;' + Escape(delText) + '&lt;/' + delTag + '&gt;';
			delText = delText.replace(/\n/g, '&amp;para;&lt;br&gt;');
			outText += delText;
		}
		if (insText != '') {
			insText = '&lt;' + insTag + ' class=&quot;diffInsert&quot;&gt;' + Escape(insText) + '&lt;/' + insTag + '&gt;';
			insText = insText.replace(/\n/g, '&amp;para;&lt;br&gt;');
			outText += insText;
		}
		outText += postText;

	} while (i &lt;= text.newWords.length);

	outText += '\n';
	outText = outText.replace(/  /g, ' &amp;nbsp;');
	outText = outText.replace(/\n/g, '&lt;br&gt;');

	return(outText);
}


// Escape: replaces html-sensitive characters in output text with character entities

function Escape(text) {

	text = text.replace(/&amp;/g, &quot;&amp;amp;&quot;);
	text = text.replace(/&lt;/g, &quot;&amp;lt;&quot;);
	text = text.replace(/&gt;/g, &quot;&amp;gt;&quot;);
	text = text.replace(/&quot;/g, &quot;&amp;quot;&quot;); //&quot;

	return(text);
}


// DetectBlocks: detect block borders and moved blocks
// input: text object, block object

function DetectBlocks(text, block) {

	block.oldStart  = [];
	block.oldToNew  = [];
	block.oldLength = [];
	block.oldWords  = [];
	block.newStart  = [];
	block.newLength = [];
	block.newWords  = [];
	block.newNumber = [];
	block.newBlock  = [];
	block.newLeft   = [];
	block.newRight  = [];
	block.newLeftIndex  = [];
	block.newRightIndex = [];

	var blockNumber = 0;
	var wordCounter = 0;
	var realWordCounter = 0;

// get old text block order
	if (showBlockMoves) {
		j = 0;
		i = 0;
		do {

// detect block boundaries on old text
			if ( (text.oldToNew[j] != i) || (blockNumber == 0 ) ) {
				if ( ( (text.oldToNew[j] != null) || (j &gt;= text.oldWords.length) ) &amp;&amp; ( (text.newToOld[i] != null) || (i &gt;= text.newWords.length) ) ) {
					if (blockNumber &gt; 0) {
						block.oldLength[blockNumber - 1] = wordCounter;
						block.oldWords[blockNumber - 1] = realWordCounter;
						wordCounter = 0;
						realWordCounter = 0;
					}

					if (j &gt;= text.oldWords.length) {
						j ++;
					}
					else {
						i = text.oldToNew[j];
						block.oldStart[blockNumber] = j;
						block.oldToNew[blockNumber] = text.oldToNew[j];
						blockNumber ++;
					}
				}
			}

// jump over identical pairs
			while ( (i &lt; text.newWords.length) &amp;&amp; (j &lt; text.oldWords.length) ) {
				if ( (text.newToOld[i] == null) || (text.oldToNew[j] == null) ) {
					break;
				}
				if (text.oldToNew[j] != i) {
					break;
				}
				i ++;
				j ++;
				wordCounter ++;
				if ( /\w/.test( text.newWords[i] ) ) {
					realWordCounter ++;
				}
			}

// jump over consecutive deletions
			while ( (text.oldToNew[j] == null) &amp;&amp; (j &lt; text.oldWords.length) ) {
				j ++;
			}

// jump over consecutive inserts
			while ( (text.newToOld[i] == null) &amp;&amp; (i &lt; text.newWords.length) ) {
				i ++;
			}
		} while (j &lt;= text.oldWords.length);

// get the block order in the new text
		var lastMin;
		var currMinIndex;
		lastMin = null;

// sort the data by increasing start numbers into new text block info
		for (i = 0; i &lt; blockNumber; i ++) {
			currMin = null;
			for (j = 0; j &lt; blockNumber; j ++) {
				curr = block.oldToNew[j];
				if ( (curr &gt; lastMin) || (lastMin == null) ) {
					if ( (curr &lt; currMin) || (currMin == null) ) {
						currMin = curr;
						currMinIndex = j;
					}
				}
			}
			block.newStart[i] = block.oldToNew[currMinIndex];
			block.newLength[i] = block.oldLength[currMinIndex];
			block.newWords[i] = block.oldWords[currMinIndex];
			block.newNumber[i] = currMinIndex;
			lastMin = currMin;
		}

// detect not moved blocks
		for (i = 0; i &lt; blockNumber; i ++) {
			if (block.newBlock[i] == null) {
				if (block.newNumber[i] == i) {
					block.newBlock[i] = 0;
				}
			}
		}

// detect switches of neighbouring blocks
		for (i = 0; i &lt; blockNumber - 1; i ++) {
			if ( (block.newBlock[i] == null) &amp;&amp; (block.newBlock[i + 1] == null) ) {
				if (block.newNumber[i] - block.newNumber[i + 1] == 1) {
					if ( (block.newNumber[i + 1] - block.newNumber[i + 2] != 1) || (i + 2 &gt;= blockNumber) ) {

// the shorter one is declared the moved one
						if (block.newLength[i] &lt; block.newLength[i + 1]) {
							block.newBlock[i] = 1;
							block.newBlock[i + 1] = 0;
						}
						else {
							block.newBlock[i] = 0;
							block.newBlock[i + 1] = 1;
						}
					}
				}
			}
		}

// mark all others as moved and number the moved blocks
		j = 1;
		for (i = 0; i &lt; blockNumber; i ++) {
			if ( (block.newBlock[i] == null) || (block.newBlock[i] == 1) ) {
				block.newBlock[i] = j++;
			}
		}

// check if a block has been moved from this block border
		for (i = 0; i &lt; blockNumber; i ++) {
			for (j = 0; j &lt; blockNumber; j ++) {

				if (block.newNumber[j] == i) {
					if (block.newBlock[j] &gt; 0) {

// block moved right
						if (block.newNumber[j] &lt; j) {
							block.newRight[i] = block.newBlock[j];
							block.newRightIndex[i] = j;
						}

// block moved left
						else {
							block.newLeft[i + 1] = block.newBlock[j];
							block.newLeftIndex[i + 1] = j;
						}
					}
				}
			}
		}
	}
	return;
}


/* &lt;/nowiki&gt;&lt;/pre&gt; */
</pre><div class="printfooter">
Retrieved from "<a href="http://en.wikipedia.org../../../a/r/m/User%7EArmandeh_diff.js_df9e.html">http://en.wikipedia.org../../../a/r/m/User%7EArmandeh_diff.js_df9e.html</a>"</div>
	    	    <!-- end content -->
	    <div class="visualClear"></div>
	  </div>
	</div>
      </div>
      <div id="column-one">
	<div id="p-cactions" class="portlet">
	  <h5>Views</h5>
	  <ul>
	    <li id="ca-nstab-user"
	       class="selected"	       ><a href="../../../a/r/m/User%7EArmandeh_diff.js_df9e.html">User page</a></li><li id="ca-talk"
	       class="new"	       ><a href="../../../a/r/m/User_talk%7EArmandeh_diff.js_d641.html">Discussion</a></li><li id="ca-current"
	       	       ><a href="http://en.wikipedia.org/wiki/User:Armandeh/diff.js">Current revision</a></li>	  </ul>
	</div>
	<div class="portlet" id="p-logo">
	  <a style="background-image: url(../../../images/wiki-en.png);"
	    href="../../../index.html"
	    title="Main Page"></a>
	</div>
	<script type="text/javascript"> if (window.isMSIE55) fixalpha(); </script>
		<div class='portlet' id='p-navigation'>
	  <h5>Navigation</h5>
	  <div class='pBody'>
	    <ul>
	    	      <li id="n-Main-page"><a href="../../../index.html">Main page</a></li>
	     	      <li id="n-Contents"><a href="../../../c/o/n/Wikipedia%7EContents_3181.html">Contents</a></li>
	     	      <li id="n-Featured-content"><a href="../../../f/e/a/Wikipedia%7EFeatured_content_24ba.html">Featured content</a></li>
	     	      <li id="n-currentevents"><a href="../../../c/u/r/Portal%7ECurrent_events_bb60.html">Current events</a></li>
	     	    </ul>
	  </div>
	</div>
		<div class='portlet' id='p-interaction'>
	  <h5>interaction</h5>
	  <div class='pBody'>
	    <ul>
	    	      <li id="n-About-Wikipedia"><a href="../../../a/b/o/Wikipedia%7EAbout_8d82.html">About Wikipedia</a></li>
	     	      <li id="n-portal"><a href="../../../c/o/m/Wikipedia%7ECommunity_Portal_6a3c.html">Community portal</a></li>
	     	      <li id="n-contact"><a href="../../../c/o/n/Wikipedia%7EContact_us_afd6.html">Contact us</a></li>
	     	      <li id="n-sitesupport"><a href="http://wikimediafoundation.org/wiki/Fundraising">Make a donation</a></li>
	     	      <li id="n-help"><a href="../../../c/o/n/Help%7EContents_22de.html">Help</a></li>
	     	    </ul>
	  </div>
	</div>
		<div id="p-search" class="portlet">
	  <h5><label for="searchInput">Search</label></h5>
	  <div id="searchBody" class="pBody">
	    <form action="javascript:goToStatic(3)" id="searchform"><div>
	      <input id="searchInput" name="search" type="text"
	        accesskey="f" value="" />
	      <input type='submit' name="go" class="searchButton" id="searchGoButton"
	        value="Go" />
	    </div></form>
	  </div>
	</div>
	      </div><!-- end of the left (by default at least) column -->
      <div class="visualClear"></div>
      <div id="footer">
    <div id="f-poweredbyico"><a href="http://www.mediawiki.org/"><img src="../../../skins/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" /></a></div>	<div id="f-copyrightico"><a href="http://wikimediafoundation.org/"><img src="../../../images/wikimedia-button.png" border="0" alt="Wikimedia Foundation"/></a></div>	<ul id="f-list">
	  	  	  <li id="f-credits">This page was last modified 17:28, 10 March 2006 by Wikipedia user <a href="../../../a/r/m/User%7EArmandeh_d115.html" title="User:Armandeh">Armandeh</a>. </li>	  <li id="f-copyright">All text is available under the terms of the <a class='internal' href="../../../t/e/x/Wikipedia%7EText_of_the_GNU_Free_Documentation_License_702a.html" title="Wikipedia:Text of the GNU Free Documentation License">GNU Free Documentation License</a>. (See <b><a class='internal' href="../../../c/o/p/Wikipedia%7ECopyrights_92c4.html" title="Wikipedia:Copyrights">Copyrights</a></b> for details.) <br /> Wikipedia&reg; is a registered trademark of the <a href="http://www.wikimediafoundation.org">Wikimedia Foundation, Inc</a>., a US-registered <a class='internal' href="../../../5/0/1/501%28c%29.html#501.28c.29.283.29" title="501(c)(3)">501(c)(3)</a> <a href="http://wikimediafoundation.org/wiki/Deductibility_of_donations">tax-deductible</a> <a class='internal' href="../../../n/o/n/Non-profit_organization.html" title="Non-profit organization">nonprofit</a> <a href="../../../c/h/a/Charitable_organization.html" title="Charitable organization">charity</a>.<br /></li>	  <li id="f-about"><a href="../../../a/b/o/Wikipedia%7EAbout_8d82.html" title="Wikipedia:About">About Wikipedia</a></li>	  <li id="f-disclaimer"><a href="../../../g/e/n/Wikipedia%7EGeneral_disclaimer_3e44.html" title="Wikipedia:General disclaimer">Disclaimers</a></li>	  	</ul>
      </div>
    </div>
  </body>
</html>
